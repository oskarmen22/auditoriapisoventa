<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Auditoría Inventario</title>
    
    <!-- 1. Librerías Necesarias -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Librería para Zoom y Pan -->
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <!-- Librería para PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <!-- Librerías para ZIP y Excel/CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Librería para escanear códigos de barras y QR -->
    <script src="https://unpkg.com/@zxing/library@latest"></script>
    
    <!-- Estilos adicionales -->
    <style>
        html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: sans-serif; background-color: #ffffff; touch-action: none; height: 100dvh; min-height: -webkit-fill-available; }
        #root { height: 100%; width: 100%; display: flex; flex-direction: column; overflow: hidden; }
        .animate-scale-up { animation: scaleUp 0.2s ease-out; }
        @keyframes scaleUp { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .resize-handle { width: 20px; height: 20px; background-color: #ef4444; position: absolute; right: -10px; bottom: -10px; cursor: se-resize; border-radius: 50%; border: 3px solid white; z-index: 20; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .rotate-handle { width: 20px; height: 20px; background-color: #eab308; position: absolute; left: 50%; top: -25px; transform: translateX(-50%); cursor: grab; border-radius: 50%; border: 3px solid white; z-index: 20; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .rotate-line { position: absolute; left: 50%; top: -25px; height: 25px; width: 2px; background-color: #eab308; transform: translateX(-50%); pointer-events: none; }
        .group-resize-handle { width: 24px; height: 24px; background-color: #000000; position: absolute; right: -12px; bottom: -12px; cursor: se-resize; border-radius: 50%; border: 3px solid white; z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .interactive-zone { pointer-events: auto !important; touch-action: none; -webkit-tap-highlight-color: rgba(0,0,0,0); }
        @keyframes pulse-red { 0%, 100% { border-color: rgba(239, 68, 68, 0.8); background-color: rgba(239, 68, 68, 0.2); transform: scale(1); } 50% { border-color: rgba(239, 68, 68, 1); background-color: rgba(239, 68, 68, 0.5); transform: scale(1.1); } }
        .highlight-zone { animation: pulse-red 1.5s infinite; z-index: 30 !important; }
        .transition-colors-fast { transition: background-color 0.3s ease, border-color 0.3s ease; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- ICONOS SVG ---
        const Icons = {
            Map: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>,
            List: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>,
            ClipboardList: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="M12 11h4"/><path d="M12 16h4"/><path d="M8 11h.01"/><path d="M8 16h.01"/></svg>,
            Save: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
            Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
            CheckCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>,
            AlertCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            RefreshCw: ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
            Server: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Minus: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Lock: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Unlock: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>,
            Code: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            AlertTriangle: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>,
            GroupSelect: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2" strokeDasharray="4 4"/><path d="M9 9h6v6H9z"/></svg>,
            Bug: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m8 2 1.88 1.88"/><path d="M14.12 3.88 16 2"/><path d="M9 7.13v-1a3.003 3.003 0 1 1 6 0v1"/><path d="M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6"/><path d="M12 20v-9"/><path d="M6.53 9C4.6 8.8 3 7.1 3 5"/><path d="M6 13H2"/><path d="M3 21c0-2.1 1.7-3.9 3.8-4"/><path d="M20.97 5c0 2.1-1.6 3.8-3.5 4"/><path d="M22 13h-4"/><path d="M17.2 17c2.1.1 3.8 1.9 3.8 4"/></svg>,
            Box: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>,
            ArrowLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>,
            MapPin: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>,
            Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
            FileText: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>,
            User: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>,
            LogOut: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>,
            Scanner: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><line x1="7" y1="8" x2="7" y2="16"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="17" y1="8" x2="17" y2="16"/></svg>
        };

        // --- URL DEL SCRIPT DE GOOGLE ---
        const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwRsXtwqtDwslArxI5BXEKXnmh2z0yw1AF4KmBoYxKYcJ83m7sa6yudKH09WWLzUgBx/exec"; 

        // --- ZONAS INICIALES ---
        const INITIAL_ZONES = [
  {
    "id": 1766548402904,
    "name": "ENTRADA (A-5)",
    "x": 444.89261323354367,
    "y": 1104.6820726018364,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548421022,
    "name": "ENTRADA (A-3)",
    "x": 547.5217170778674,
    "y": 1102.968128609779,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548427662,
    "name": "ENTRADA (A-1)",
    "x": 648.1346976528255,
    "y": 1104.809671143215,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548435648,
    "name": "ENTRADA (A-6)",
    "x": 444.89400084708933,
    "y": 1203.8943998918642,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548445396,
    "name": "ENTRADA (A-4)",
    "x": 544.3148898032066,
    "y": 1204.358158640711,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548455674,
    "name": "ENTRADA (A-2)",
    "x": 648.0232223808124,
    "y": 1208.4548982569042,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548496424,
    "name": "ENTRADA (B-1)",
    "x": 1109.474317377391,
    "y": 804.4071559633883,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 66.45,
    "type": "rect"
  },
  {
    "id": 1766548509372,
    "name": "ENTRADA (B-2)",
    "x": 1148.3077008468977,
    "y": 894.5373311988767,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 66.61,
    "type": "rect"
  },
  {
    "id": 1766548531211,
    "name": "ENTRADA (B-3)",
    "x": 1185.164008080786,
    "y": 984.3266305756822,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 64.93,
    "type": "rect"
  },
  {
    "id": 1766548552812,
    "name": "ENTRADA (B-4)",
    "x": 1223.3756738814195,
    "y": 1079.2841618248763,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 66.01,
    "type": "rect"
  },
  {
    "id": 1766548668091,
    "name": "RECIBA 1 (A-3)",
    "x": 1185.5308285297224,
    "y": 722.0363737361852,
    "w": 82.71067404365279,
    "h": 82.71067404365279,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548680572,
    "name": "RECIBA 1 (A-2)",
    "x": 1269.20132087384,
    "y": 720.5131337494229,
    "w": 82.71067404365279,
    "h": 82.71067404365279,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766548691340,
    "name": "RECIBA 1 (A-1)",
    "x": 1345.77646121531,
    "y": 722.7503177282425,
    "w": 82.71067404365279,
    "h": 82.71067404365279,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552613704,
    "name": "RECIBA 1 (B-1)",
    "x": 1208.0920099290756,
    "y": 506.96172816232234,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552633782,
    "name": "RECIBA 1 (B-2)",
    "x": 1107.96045075453,
    "y": 506.52396459328,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552647339,
    "name": "RECIBA 1 (B-3)",
    "x": 1210.1242564678068,
    "y": 405.22283652235166,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552655184,
    "name": "RECIBA 1 (B-4)",
    "x": 1107.3142230240123,
    "y": 403.8397916249468,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552666874,
    "name": "RECIBA 1 (B-5)",
    "x": 1206.1581904829036,
    "y": 306.7422676446013,
    "w": 83.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552675409,
    "name": "RECIBA 1 (B-6)",
    "x": 1105.3320337697437,
    "y": 307.2913547170023,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552810676,
    "name": "RECIBA 1 (E. IZQUIERDA-1)",
    "x": 1234.4059294064755,
    "y": 218.0565410981261,
    "w": 103.38834255456598,
    "h": 77.54125691592448,
    "r": -44.35,
    "type": "rect"
  },
  {
    "id": 1766552851546,
    "name": "RECIBA 1 (E. IZQUIERDA-2)",
    "x": 1182.2465105876972,
    "y": 170.0326559815303,
    "w": 103.38834255456598,
    "h": 77.54125691592448,
    "r": -46.44,
    "type": "rect"
  },
  {
    "id": 1766552904868,
    "name": "RECIBA 1 (C-1)",
    "x": 1323.6105202194167,
    "y": 187.1049830406934,
    "w": 103.38834255456598,
    "h": 80.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552918732,
    "name": "RECIBA 1 (C-2)",
    "x": 1325.1211636582002,
    "y": 86.01703110796655,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552931604,
    "name": "RECIBA 1 (C-3)",
    "x": 1425.1591594855677,
    "y": 182.20033504334089,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552942018,
    "name": "RECIBA 1 (C-4)",
    "x": 1423.9506447345407,
    "y": 84.26746562444595,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552958418,
    "name": "RECIBA 1 (C-5)",
    "x": 1524.5394657002262,
    "y": 183.20033504334089,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552965808,
    "name": "RECIBA 1 (C-6)",
    "x": 1525.6348177028744,
    "y": 83.90734449142252,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552976176,
    "name": "RECIBA 1 (C-7)",
    "x": 1624.1282866659121,
    "y": 186.1049830406934,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552984430,
    "name": "RECIBA 1 (C-8)",
    "x": 1626.0409710031718,
    "y": 86.7941817430434,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766552992785,
    "name": "RECIBA 1 (C-9)",
    "x": 1727.045083404993,
    "y": 189.39103904863612,
    "w": 104.38834255456598,
    "h": 81.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553002034,
    "name": "RECIBA 1 (C-10)",
    "x": 1721.2357874102881,
    "y": 89.91538083132957,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553018687,
    "name": "RECIBA 1 (E. DERECHA-1)",
    "x": 1819.609795350958,
    "y": 219.2972012087809,
    "w": 103.38834255456598,
    "h": 77.54125691592448,
    "r": 45.02,
    "type": "rect"
  },
  {
    "id": 1766553040109,
    "name": "RECIBA 1 (E. DERECHA-2)",
    "x": 1871.6916729128206,
    "y": 163.85520251389482,
    "w": 103.38834255456598,
    "h": 77.54125691592448,
    "r": 45.75,
    "type": "rect"
  },
  {
    "id": 1766553151213,
    "name": "RECIBA 1 (D-1)",
    "x": 1874.1030581305654,
    "y": 304.97399182688804,
    "w": 75.38834255456598,
    "h": 102.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553159387,
    "name": "RECIBA 1 (D-2)",
    "x": 1949.4914006851313,
    "y": 300.97399182688804,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553169979,
    "name": "RECIBA 1 (D-3)",
    "x": 1844.2937621358606,
    "y": 399.76155313777593,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553179373,
    "name": "RECIBA 1 (D-4)",
    "x": 1946.0020441239144,
    "y": 403.45768638410146,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553196569,
    "name": "RECIBA 1 (D-5)",
    "x": 1895.496838786009,
    "y": 503.0465073497874,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553207725,
    "name": "RECIBA 1 (D-6)",
    "x": 1897.2802876950755,
    "y": 604.5480126527325,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553222062,
    "name": "RECIBA 1 (D-7)",
    "x": 1894.5921907886568,
    "y": 700.6474770572014,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553234687,
    "name": "RECIBA 1 (D-8)",
    "x": 1840.8835331288228,
    "y": 1001.6707233342789,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553241865,
    "name": "RECIBA 1 (D-9)",
    "x": 1843.0531020252056,
    "y": 1104.8442022742772,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553352547,
    "name": "PLANTA1 (A-1)",
    "x": 1693.4243232631097,
    "y": 1203.3732927287786,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553376037,
    "name": "PLANTA1 (A-2)",
    "x": 1793.426697599014,
    "y": 1203.3732927287786,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553383443,
    "name": "PLANTA1 (A-3)",
    "x": 1894.5921907886568,
    "y": 1199.883936167562,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553393197,
    "name": "PLANTA1 (A-4)",
    "x": 1995.7576839782992,
    "y": 1204.5364115825173,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553401867,
    "name": "PLANTA1 (A-5)",
    "x": 2094.571092374826,
    "y": 1202.21017387504,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553409445,
    "name": "PLANTA1 (A-6)",
    "x": 2198.062823271947,
    "y": 1202.21017387504,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553415764,
    "name": "PLANTA1 (A-7)",
    "x": 2293.412722192895,
    "y": 1201.0470550213008,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553422329,
    "name": "PLANTA1 (A-8)",
    "x": 2394.552368296899,
    "y": 1202.21017387504,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553430143,
    "name": "PLANTA1 (A-9)",
    "x": 2493.3916237790645,
    "y": 1202.21017387504,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553437254,
    "name": "PLANTA1 (A-10)",
    "x": 2596.883354676185,
    "y": 1204.5364115825173,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553446891,
    "name": "PLANTA1 (A-11)",
    "x": 2700.3750855733056,
    "y": 1196.3945796063456,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553457453,
    "name": "PLANTA1 (A-12)",
    "x": 2696.885729012089,
    "y": 1102.207799539136,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553517953,
    "name": "PLANTA2 (A-1)",
    "x": 2193.720512884655,
    "y": 1553.3428322759844,
    "w": 206.77668510913196,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553544397,
    "name": "PLANTA2 (A-2)",
    "x": 2193.074335743689,
    "y": 1652.1820877581495,
    "w": 206.77668510913196,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553593038,
    "name": "PLANTA2 (A-3)",
    "x": 2397.085382689486,
    "y": 1553.0843614195983,
    "w": 103.38834255456598,
    "h": 206.77668510913196,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553612405,
    "name": "PLANTA2 (A-4)",
    "x": 2494.2187305195007,
    "y": 1549.336534001995,
    "w": 103.38834255456598,
    "h": 206.77668510913196,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553628189,
    "name": "PLANTA2 (A-5)",
    "x": 2593.0579860016655,
    "y": 1551.6627717094732,
    "w": 103.38834255456598,
    "h": 206.77668510913196,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553642605,
    "name": "PLANTA2 (A-6)",
    "x": 2694.223479191309,
    "y": 1551.6627717094732,
    "w": 103.38834255456598,
    "h": 206.77668510913196,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553661739,
    "name": "PLANTA2 (A-7)",
    "x": 2795.388972380951,
    "y": 1553.9890094169505,
    "w": 103.38834255456598,
    "h": 206.77668510913196,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553741936,
    "name": "PLANTA2 (B-1)",
    "x": 2895.5205821450486,
    "y": 2203.7330482011207,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553763186,
    "name": "PLANTA2 (B-2)",
    "x": 2794.458477297961,
    "y": 2203.7330482011207,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553791686,
    "name": "PLANTA2 (C-1)",
    "x": 2593.3681510293295,
    "y": 2107.8662075673988,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553797674,
    "name": "PLANTA2 (C-2)",
    "x": 2594.531269883069,
    "y": 2208.4113707017145,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553805522,
    "name": "PLANTA2 (C-3)",
    "x": 2594.531269883069,
    "y": 2303.089245396058,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553812858,
    "name": "PLANTA2 (C-4)",
    "x": 2594.531269883069,
    "y": 2405.495398696356,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553825586,
    "name": "PLANTA2 (C-5)",
    "x": 2495.640320229626,
    "y": 2101.7662953566796,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553835900,
    "name": "PLANTA2 (C-7)",
    "x": 2496.3123444562307,
    "y": 2306.190895672695,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553866008,
    "name": "PLANTA2 (C-6)",
    "x": 2493.9861067487536,
    "y": 2203.7330482011207,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553873706,
    "name": "PLANTA2 (C-8)",
    "x": 2495.1492256024917,
    "y": 2403.6344085303735,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553883926,
    "name": "PLANTA2 (C-9)",
    "x": 2393.932038241572,
    "y": 2051.7263375602697,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553894068,
    "name": "PLANTA2 (C-10)",
    "x": 2392.5104485314464,
    "y": 2148.5236732769818,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553905454,
    "name": "PLANTA2 (C-11)",
    "x": 2391.088858821321,
    "y": 2249.327307267684,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553914450,
    "name": "PLANTA2 (C-12)",
    "x": 2395.7671813219154,
    "y": 2405.9864933234903,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553923116,
    "name": "PLANTA2 (C-13)",
    "x": 2292.8957804801216,
    "y": 2105.514122774283,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766553930478,
    "name": "DE CARGA (A-1)",
    "x": 946.2402477530968,
    "y": 1702.4029751540302,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766554052179,
    "name": "DE CARGA (A-2)",
    "x": 946.2402477530968,
    "y": 1607.6217121171314,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766554061360,
    "name": "DE CARGA (A-3)",
    "x": 944.117310598893,
    "y": 1503.7164278497926,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1766554072806,
    "name": "DE CARGA (A-4)",
    "x": 946.2402477530968,
    "y": 1405.0581019670985,
    "w": 103.38834255456598,
    "h": 103.38834255456598,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1767048802736,
    "name": "CHIQUILLADAS",
    "type": "polygon",
    "points": [
      {
        "x": 1218.8740668337512,
        "y": 850.950522974102
      },
      {
        "x": 1427.3628621553885,
        "y": 852.812030075188
      },
      {
        "x": 1421.7783408521304,
        "y": 1161.8222088554721
      },
      {
        "x": 1343.5950426065162,
        "y": 1161.8222088554721
      }
    ],
    "r": 0
  },
  {
    "id": 1767134790959,
    "name": "PLANTA2 (C-14)",
    "x": 2293.3198607135255,
    "y": 2207.614974967572,
    "w": 100,
    "h": 101,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1767134806743,
    "name": "PLANTA2 (C-15)",
    "x": 2294.0904767209877,
    "y": 2309.76568315786,
    "w": 103,
    "h": 98,
    "r": 0,
    "type": "rect"
  },
  {
    "id": 1767134818335,
    "name": "PLANTA2 (C-16)",
    "x": 2296.4918987079286,
    "y": 2405.916391348148,
    "w": 98,
    "h": 103,
    "r": 0,
    "type": "rect"
  }
];

        // Zonas iniciales para la vista PLANOGRAMA (CHIQUILLADAS)
        const INITIAL_ZONES_PLANOGRAMA = [
          {
            "id": 1767055933653,
            "name": "ESTANTE DE 01-02 KG (A-1)",
            "x": 316.69040496880064,
            "y": 1463.183209708221,
            "w": 187,
            "h": 213,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767056063822,
            "name": "ESTANTE DE 01-02 KG (A-2)",
            "x": 665.9927210201085,
            "y": 1560.1196757567443,
            "w": 230,
            "h": 143,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767056164484,
            "name": "ESTANTE DE 01-02 KG (B-1)",
            "x": 182.30537716218373,
            "y": 1226.3418943597183,
            "w": 116,
            "h": 110,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767056926567,
            "name": "ESTANTE DE 01-02 KG (B-2)",
            "x": 318.33890281258704,
            "y": 1216.007170704539,
            "w": 120,
            "h": 115,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767056963649,
            "name": "ESTANTE DE 01-02 KG (B-3)",
            "x": 454.9331662489557,
            "y": 1223.5070314675577,
            "w": 109,
            "h": 104,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767057002939,
            "name": "ESTANTE DE 01-02 KG (B-4)",
            "x": 595.6836535783905,
            "y": 1117.7568226120857,
            "w": 164,
            "h": 206,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069807431,
            "name": "ESTANTE DE 01-02 KG (C-1)",
            "x": 175.43993316624898,
            "y": 479.6846115288221,
            "w": 188,
            "h": 424,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069826241,
            "name": "ESTANTE DE 01-02 KG (C-2)",
            "x": 377.02553049289895,
            "y": 482.64447786131996,
            "w": 191,
            "h": 421,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069846949,
            "name": "ESTANTE DE 01-02 KG (C-3)",
            "x": 584.3261152882205,
            "y": 485.9843609022556,
            "w": 204,
            "h": 416,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069887581,
            "name": "ESTANTE DE 01-02 KG (C-4)",
            "x": 799.6267000835422,
            "y": 492.18419381787805,
            "w": 194,
            "h": 403,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069917899,
            "name": "ESTANTE DE 01-02 KG (D-1)",
            "x": 171.7601670843776,
            "y": 278.06870509607353,
            "w": 384,
            "h": 158,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069939453,
            "name": "ESTANTE DE 01-02 KG (D-2)",
            "x": 605.7667502088555,
            "y": 243.49868003341686,
            "w": 552,
            "h": 191,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069967117,
            "name": "ESTANTE DE 01-02 KG (D-3)",
            "x": 1203.2983124477862,
            "y": 276.68868838763575,
            "w": 376,
            "h": 152,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767069991387,
            "name": "ESTANTE DE 01-02 KG (D-4)",
            "x": 1595.7094736842105,
            "y": 281.2136675020885,
            "w": 388,
            "h": 153,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767070088081,
            "name": "ESTANTE DE 01-02 KG (B-5)",
            "x": 811.1581591245076,
            "y": 1116.4386785624406,
            "w": 162,
            "h": 201,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767071699392,
            "name": "ESTANTE DE 05 KG (A-9)",
            "x": 4007.446784961047,
            "y": 1376.9315075893383,
            "w": 207,
            "h": 367,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072154712,
            "name": "ESTANTE DE 05 KG (A-8)",
            "x": 3829.0141714285714,
            "y": 1372.4443749373434,
            "w": 181,
            "h": 377,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072177327,
            "name": "ESTANTE DE 05 KG (A-7)",
            "x": 3643.204038095238,
            "y": 1375.1069834586467,
            "w": 168,
            "h": 370,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072193315,
            "name": "ESTANTE DE 05 KG (C-6)",
            "x": 4020.294540350877,
            "y": 543.2093914786967,
            "w": 167,
            "h": 372,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072221891,
            "name": "ESTANTE DE 05 KG (B-5)",
            "x": 3837.6922666666665,
            "y": 973.72447518797,
            "w": 166,
            "h": 372,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072761111,
            "name": "ESTANTE DE 05 KG (A-6)",
            "x": 3476.335396108987,
            "y": 1370.9810360085644,
            "w": 146,
            "h": 376,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072895016,
            "name": "ESTANTE DE 05 KG (A-5)",
            "x": 3300.311566917293,
            "y": 1370.0321283208018,
            "w": 147,
            "h": 374,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072906022,
            "name": "ESTANTE DE 05 KG (A-4)",
            "x": 3104.96835689223,
            "y": 1362.6526636591477,
            "w": 166,
            "h": 382,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072927116,
            "name": "ESTANTE DE 05 KG (A-3)",
            "x": 2901.9082907268166,
            "y": 1372.4539348370927,
            "w": 174,
            "h": 372,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072942768,
            "name": "ESTANTE DE 05 KG (A-2)",
            "x": 2720.9474606516287,
            "y": 1375.3484832080198,
            "w": 174,
            "h": 365,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767072955022,
            "name": "ESTANTE DE 05 KG (A-1)",
            "x": 2528.7307388471177,
            "y": 1364.044302756892,
            "w": 180,
            "h": 377,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073022424,
            "name": "ESTANTE DE 05 KG (B-6)",
            "x": 4012.3591311347,
            "y": 958.904093068622,
            "w": 194,
            "h": 371,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073076226,
            "name": "ESTANTE DE 05 KG (B-2)",
            "x": 3285.8132373462045,
            "y": 963.1102717354372,
            "w": 170,
            "h": 370,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073125204,
            "name": "ESTANTE DE 05 KG (B-3)",
            "x": 3467.217862744365,
            "y": 958.5679974152545,
            "w": 159,
            "h": 374,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073138042,
            "name": "ESTANTE DE 05 KG (B-4)",
            "x": 3646.06106694034,
            "y": 956.0453015823226,
            "w": 181,
            "h": 378,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073151530,
            "name": "ESTANTE DE 05 KG (B-1)",
            "x": 3093.202018937154,
            "y": 973.1023870024019,
            "w": 171,
            "h": 363,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073209306,
            "name": "ESTANTE DE 05 KG (C-1)",
            "x": 3094.380220426402,
            "y": 552.775414752965,
            "w": 178,
            "h": 374,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073219716,
            "name": "ESTANTE DE 05 KG (C-2)",
            "x": 3282.0268545575077,
            "y": 549.5989218124969,
            "w": 176,
            "h": 379,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073236012,
            "name": "ESTANTE DE 05 KG (C-3)",
            "x": 3465.8108031965285,
            "y": 547.5597433799438,
            "w": 171,
            "h": 373,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073249124,
            "name": "ESTANTE DE 05 KG (C-4)",
            "x": 3649.8104232085702,
            "y": 554.775414752965,
            "w": 170,
            "h": 364,
            "r": 0,
            "type": "rect"
          },
          {
            "id": 1767073293892,
            "name": "ESTANTE DE 05 KG (C-5)",
            "x": 3830.2022075341015,
            "y": 557.1806385439721,
            "w": 172,
            "h": 355,
            "r": 0,
            "type": "rect"
          }
        ];

        // --- FUNCIONES AUXILIARES ---
        // Extrae el nombre del producto, eliminando el código si existe.
        const getProductName = (fullString) => {
            if (!fullString) return "";
            const parts = fullString.split('-');
            if (parts.length > 1) {
                // Si hay guión, asumimos formato CODIGO-NOMBRE. Retornamos todo después del primer guión.
                return parts.slice(1).join('-').trim();
            }
            return fullString;
        };
        
        // Extrae el código del producto.
        const getProductCode = (fullString) => {
            if (!fullString) return "";
            const parts = fullString.split('-');
            if (parts.length > 1) {
                 return parts[0].trim();
            }
            return "";
        };

        // --- COMPONENTE DE CONSOLA DE DEBUG ---
        const DebugConsole = ({ logs }) => {
            if (!logs || logs.length === 0) return null;
            return (
                <div className="fixed bottom-20 left-4 z-50 pointer-events-none opacity-80">
                    <div className="bg-black/80 text-green-400 p-2 rounded text-[10px] font-mono w-64 max-h-32 overflow-hidden flex flex-col-reverse shadow-lg border border-green-900">
                        {logs.slice(-5).map((log, i) => (
                            <div key={i}>{log}</div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- COMPONENTES DE UI GENÉRICOS ---

        const Modal = ({ isOpen, onClose, title, children, zIndex = 100, align = 'center' }) => {
            if (!isOpen) return null;
            const alignmentClass = align === 'top' ? 'items-start pt-12' : 'items-center';

            return (
                <div className={`fixed inset-0 bg-black bg-opacity-50 flex ${alignmentClass} justify-center p-4 animate-fade-in`} style={{zIndex: zIndex}}>
                    <div className="bg-white rounded-lg shadow-xl w-full max-w-md overflow-hidden animate-scale-up border-t-4 border-red-600">
                        <div className="bg-white p-4 flex justify-between items-center text-slate-800 border-b border-gray-100">
                            <h3 className="font-bold text-lg">{title}</h3>
                            {onClose && <button onClick={onClose} className="hover:bg-gray-100 p-1 rounded text-gray-500"><Icons.X /></button>}
                        </div>
                        <div className="p-4">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        // Helper para mostrar producto limpio (sin código)
        const cleanProductName = (fullName) => {
            if (!fullName) return '';
            // Si tiene guión, tomar todo después del primer guión
            if (fullName.includes('-')) {
                return fullName.substring(fullName.indexOf('-') + 1).trim();
            }
            return fullName;
        };

        // Helper para extraer código y nombre para reportes
        const extractCodeAndName = (fullName) => {
            if (!fullName) return { code: '', name: '' };
            if (fullName.includes('-')) {
                const parts = fullName.split('-');
                const code = parts[0].trim();
                const name = parts.slice(1).join('-').trim();
                return { code, name };
            }
            return { code: '', name: fullName };
        };

        const AutocompleteInput = ({ items, value, onChange, placeholder, onSelect, onEnter, inputRef, autoFocus, showFullNames = false }) => {
            const [suggestions, setSuggestions] = React.useState([]);
            const [showSuggestions, setShowSuggestions] = React.useState(false);

            // Filtrar usando el nombre limpio pero manteniendo la referencia al original
            // Si showFullNames es true (para ubicaciones), buscar en el nombre completo
            const getFilteredSuggestions = (query) => {
                if (!query) return [];
                const lowerQuery = query.toLowerCase();
                return items.filter(item => {
                    if (showFullNames) {
                        // Para ubicaciones: buscar en el nombre completo
                        return String(item).toLowerCase().includes(lowerQuery);
                    } else {
                        // Para productos: buscar en el nombre limpio (sin código)
                        const cleanName = cleanProductName(item);
                        return cleanName.toLowerCase().includes(lowerQuery);
                    }
                });
            };

            const handleChange = (e) => {
                const inputVal = e.target.value;
                onChange(inputVal); // El padre recibe lo que se escribe tal cual (para nuevos productos)
                
                if (inputVal.length > 0) {
                    const filtered = getFilteredSuggestions(inputVal);
                    setSuggestions(filtered);
                    setShowSuggestions(true);
                } else {
                    setShowSuggestions(false);
                }
            };

            const handleSelect = (fullItemString) => {
                onChange(fullItemString); // Enviar el string completo (CODE-NAME) al padre
                setShowSuggestions(false);
                if (onSelect) onSelect(fullItemString);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    // Seleccionar el primero de la lista si hay sugerencias visibles
                    if (showSuggestions && suggestions.length > 0) {
                        const firstItem = String(suggestions[0]);
                        onChange(firstItem); 
                        if (onSelect) onSelect(firstItem);
                    }
                    
                    setShowSuggestions(false);
                    
                    if (onEnter) onEnter();
                }
            };

            // Valor a mostrar en el input: 
            // Si showFullNames es true (ubicaciones), mostrar el nombre completo
            // Si es para productos, mostrar limpio (sin código)
            const displayValue = value && items.includes(value) 
                ? (showFullNames ? value : cleanProductName(value)) 
                : value;

            return (
                <div className="relative w-full">
                    <input 
                        ref={inputRef}
                        type="text" 
                        className="w-full p-3 border border-slate-300 rounded-lg bg-white focus:ring-2 focus:ring-yellow-400 outline-none" 
                        placeholder={placeholder} 
                        value={displayValue} 
                        onChange={(e) => {
                            // Cuando el usuario escribe, asumimos que está escribiendo el nombre
                            // Pasamos el valor crudo al padre, pero el input es controlado.
                            // Esto es un poco truco: si el padre tiene el valor "CODE-NAME", displayValue lo limpia.
                            // Si el usuario borra una letra, el padre recibe "NAM". "NAM" no está en items, así que displayValue es "NAM".
                            handleChange(e);
                        }} 
                        onFocus={(e) => {
                            e.target.select();
                            if (displayValue && displayValue.length > 0) {
                                const filtered = getFilteredSuggestions(displayValue);
                                setSuggestions(filtered);
                                setShowSuggestions(true);
                            }
                        }}
                        onKeyDown={handleKeyDown}
                        autoFocus={autoFocus}
                    />
                    {showSuggestions && suggestions.length > 0 && (
                        <ul className="absolute z-50 w-full bg-white border border-slate-200 rounded-lg mt-1 max-h-48 overflow-y-auto shadow-xl">
                            {suggestions.map((item, idx) => (
                                <li key={idx} className="p-3 hover:bg-yellow-50 cursor-pointer border-b border-slate-50 text-sm text-slate-700" onClick={() => handleSelect(item)}>
                                    {showFullNames ? item : cleanProductName(item)}
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            );
        };

        // --- COMPONENTE DE ESCÁNER ---
        const ScannerComponent = ({ activeTab, onCodeScanned }) => {
            const videoRef = React.useRef(null);
            const streamRef = React.useRef(null);
            const codeReaderRef = React.useRef(null);
            const manualInputRef = React.useRef(null);
            const [isScanning, setIsScanning] = React.useState(false);
            const [scannedCode, setScannedCode] = React.useState('');
            const [isCameraActive, setIsCameraActive] = React.useState(false);
            const [isPressed, setIsPressed] = React.useState(false);
            const [isDetecting, setIsDetecting] = React.useState(false);
            const [detectedCode, setDetectedCode] = React.useState('');
            const [isAutoMode, setIsAutoMode] = React.useState(true); // Modo automático por defecto
            const [isTorchOn, setIsTorchOn] = React.useState(false);
            const [torchSupported, setTorchSupported] = React.useState(false);
            const [manualCode, setManualCode] = React.useState('');
            const [lastScannedCode, setLastScannedCode] = React.useState('');
            const timerRef = React.useRef(null);
            const hasScannedRef = React.useRef(false);
            const scanIntervalRef = React.useRef(null);
            const autoScanIntervalRef = React.useRef(null);
            const isScanningActiveRef = React.useRef(false);

            // Inicializar ZXing cuando se monta el componente
            React.useEffect(() => {
                if (window.ZXing) {
                    codeReaderRef.current = new window.ZXing.BrowserMultiFormatReader();
                }

                return () => {
                    stopCamera();
                    if (timerRef.current) clearInterval(timerRef.current);
                    if (scanIntervalRef.current) clearInterval(scanIntervalRef.current);
                    if (autoScanIntervalRef.current) clearInterval(autoScanIntervalRef.current);
                };
            }, []);

            // Iniciar cámara cuando se selecciona la pestaña Escáner
            React.useEffect(() => {
                if (activeTab === 'scanner') {
                    if (!isCameraActive && window.ZXing) {
                        if (!codeReaderRef.current) {
                            codeReaderRef.current = new window.ZXing.BrowserMultiFormatReader();
                        }
                        startCamera();
                    } else if (streamRef.current && streamRef.current.active) {
                        const video = videoRef.current;
                        if (video) {
                            video.srcObject = streamRef.current;
                            video.play().catch(err => console.error('Error playing video:', err));
                            setIsCameraActive(true);
                        }
                    }
                } else {
                    if (videoRef.current && streamRef.current && streamRef.current.active) {
                        videoRef.current.pause();
                        setIsCameraActive(false);
                    } else if (isCameraActive) {
                        stopCamera();
                    }
                }
            }, [activeTab]);

            // Escaneo automático cuando está activo
            React.useEffect(() => {
                if (isCameraActive && isAutoMode && !isPressed && !hasScannedRef.current) {
                    autoScanIntervalRef.current = setInterval(() => {
                        scanCenterArea(true);
                    }, 300);
                } else {
                    if (autoScanIntervalRef.current) {
                        clearInterval(autoScanIntervalRef.current);
                        autoScanIntervalRef.current = null;
                    }
                }

                return () => {
                    if (autoScanIntervalRef.current) {
                        clearInterval(autoScanIntervalRef.current);
                    }
                };
            }, [isCameraActive, isAutoMode, isPressed]);

            const startCamera = async () => {
                try {
                    if (!window.ZXing) {
                        console.error('ZXing library not loaded');
                        return;
                    }

                    const video = videoRef.current;
                    if (!video) return;

                    if (streamRef.current && streamRef.current.active) {
                        video.srcObject = streamRef.current;
                        await video.play();
                        setIsCameraActive(true);
                        checkTorchSupport();
                        return;
                    }

                    // Obtener stream de la cámara con soporte para linterna
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            torch: isTorchOn
                        }
                    };

                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    streamRef.current = stream;
                    video.srcObject = stream;
                    await video.play();
                    setIsCameraActive(true);
                    checkTorchSupport();
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    if (error.name !== 'NotAllowedError' && error.name !== 'PermissionDeniedError') {
                        alert('No se pudo acceder a la cámara. Por favor, permite el acceso a la cámara.');
                    }
                }
            };

            const checkTorchSupport = () => {
                if (streamRef.current && streamRef.current.getVideoTracks().length > 0) {
                    const track = streamRef.current.getVideoTracks()[0];
                    const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                    setTorchSupported(capabilities.torch || false);
                }
            };

            const toggleTorch = async () => {
                if (!streamRef.current) return;
                
                const track = streamRef.current.getVideoTracks()[0];
                if (track && track.getCapabilities && track.getCapabilities().torch) {
                    try {
                        await track.applyConstraints({
                            advanced: [{ torch: !isTorchOn }]
                        });
                        setIsTorchOn(!isTorchOn);
                    } catch (error) {
                        console.error('Error toggling torch:', error);
                    }
                }
            };

            const stopCamera = () => {
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                    streamRef.current = null;
                }
                if (videoRef.current) {
                    videoRef.current.srcObject = null;
                }
                setIsCameraActive(false);
                setIsScanning(false);
                setIsPressed(false);
                setIsDetecting(false);
                setDetectedCode('');
                setIsTorchOn(false);
                hasScannedRef.current = false;
                if (scanIntervalRef.current) {
                    clearInterval(scanIntervalRef.current);
                    scanIntervalRef.current = null;
                }
                if (autoScanIntervalRef.current) {
                    clearInterval(autoScanIntervalRef.current);
                    autoScanIntervalRef.current = null;
                }
            };

            const playBeep = () => {
                try {
                    // Crear sonido de bip largo
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800; // Frecuencia del bip
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.error('Error playing beep:', error);
                }
            };

            const vibrate = () => {
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]); // Vibración fuerte
                }
            };

            // Procesar imagen para mejorar detección (contraste, brillo)
            const enhanceImage = (canvas, ctx) => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Aplicar mejoras de contraste y brillo
                const contrast = 1.2;
                const brightness = 10;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Aplicar contraste
                    data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128));
                    data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128));
                    data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128));
                    
                    // Aplicar brillo
                    data[i] = Math.min(255, Math.max(0, data[i] + brightness));
                    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + brightness));
                    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + brightness));
                }
                
                ctx.putImageData(imageData, 0, 0);
            };

            // Escanear área central con mejor procesamiento
            const scanCenterArea = async (isAuto = false) => {
                if (!isCameraActive || !videoRef.current || !codeReaderRef.current) return;
                if (isScanningActiveRef.current) return;
                if (hasScannedRef.current && !isAuto) return;

                isScanningActiveRef.current = true;

                try {
                    const codeReader = codeReaderRef.current;
                    const video = videoRef.current;
                    
                    if (!video.videoWidth || !video.videoHeight) {
                        isScanningActiveRef.current = false;
                        return;
                    }

                    const videoWidth = video.videoWidth;
                    const videoHeight = video.videoHeight;
                    
                    // Área central: 50% del tamaño menor, centrado
                    const scanAreaSize = Math.min(videoWidth, videoHeight) * 0.5;
                    const centerX = videoWidth / 2;
                    const centerY = videoHeight / 2;
                    const startX = centerX - scanAreaSize / 2;
                    const startY = centerY - scanAreaSize / 2;

                    // Crear canvas solo con el área central
                    const canvas = document.createElement('canvas');
                    canvas.width = scanAreaSize;
                    canvas.height = scanAreaSize;
                    const ctx = canvas.getContext('2d');
                    
                    // Dibujar área central
                    ctx.drawImage(
                        video, 
                        startX, startY, scanAreaSize, scanAreaSize,
                        0, 0, scanAreaSize, scanAreaSize
                    );

                    // Mejorar imagen para mejor detección
                    enhanceImage(canvas, ctx);

                    // Convertir a imagen
                    const img = new Image();
                    img.src = canvas.toDataURL('image/png');
                    
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        setTimeout(() => reject(new Error('Image load timeout')), 300);
                    });

                    // Intentar decodificar
                    const result = await codeReader.decodeFromImageElement(img);
                    
                    if (result) {
                        const code = result.getText();
                        
                        // Evitar escanear el mismo código repetidamente
                        if (code === lastScannedCode && isAuto) {
                            isScanningActiveRef.current = false;
                            return;
                        }

                        setScannedCode(code);
                        setLastScannedCode(code);
                        playBeep();
                        vibrate();
                        hasScannedRef.current = true;
                        setIsScanning(false);
                        setIsDetecting(true);
                        
                        // Buscar en base de datos
                        if (onCodeScanned) {
                            onCodeScanned(code);
                        }
                        
                        // En modo automático, resetear después de 2 segundos
                        if (isAuto) {
                            setTimeout(() => {
                                hasScannedRef.current = false;
                                setIsDetecting(false);
                            }, 2000);
                        }
                    } else {
                        setIsDetecting(false);
                    }
                } catch (error) {
                    setIsDetecting(false);
                } finally {
                    isScanningActiveRef.current = false;
                }
            };

            const handlePressStart = () => {
                if (!isCameraActive) {
                    startCamera();
                    return;
                }
                
                if (!isAutoMode) {
                    setIsPressed(true);
                    hasScannedRef.current = false;
                    setIsScanning(true);
                    scanCenterArea(false);
                }
            };

            const handlePressEnd = () => {
                if (!isAutoMode) {
                    setIsPressed(false);
                    setIsScanning(false);
                    hasScannedRef.current = false;
                }
            };

            const handleManualSearch = (e) => {
                if (e.key === 'Enter' && manualCode.trim()) {
                    const code = manualCode.trim();
                    setScannedCode(code);
                    if (onCodeScanned) {
                        onCodeScanned(code);
                    }
                    setManualCode('');
                }
            };

            const toggleAutoMode = () => {
                setIsAutoMode(!isAutoMode);
                hasScannedRef.current = false;
                setIsDetecting(false);
            };

            return (
                <div className="h-full flex flex-col bg-black relative">
                    {/* Controles superiores */}
                    {isCameraActive && (
                        <div className="absolute top-4 left-4 right-4 z-30 flex gap-2 flex-wrap">
                            {/* Toggle Modo Automático/Manual */}
                            <button
                                onClick={toggleAutoMode}
                                className={`px-4 py-2 rounded-lg font-bold text-sm shadow-lg transition-all ${
                                    isAutoMode 
                                        ? 'bg-green-600 text-white' 
                                        : 'bg-white/20 text-white backdrop-blur-sm'
                                }`}
                            >
                                {isAutoMode ? '✓ Auto' : 'Manual'}
                            </button>
                            
                            {/* Botón Linterna */}
                            {torchSupported && (
                                <button
                                    onClick={toggleTorch}
                                    className={`px-4 py-2 rounded-lg font-bold text-sm shadow-lg transition-all ${
                                        isTorchOn 
                                            ? 'bg-yellow-500 text-black' 
                                            : 'bg-white/20 text-white backdrop-blur-sm'
                                    }`}
                                >
                                    {isTorchOn ? '💡 ON' : '💡 OFF'}
                                </button>
                            )}
                        </div>
                    )}

                    {/* Campo de búsqueda manual */}
                    <div className="absolute bottom-4 left-4 right-4 z-30">
                        <div className="bg-white/95 backdrop-blur-sm rounded-lg p-3 shadow-xl">
                            <div className="flex gap-2">
                                <input
                                    ref={manualInputRef}
                                    type="text"
                                    value={manualCode}
                                    onChange={(e) => setManualCode(e.target.value)}
                                    onKeyPress={handleManualSearch}
                                    placeholder="Ingresa código y presiona Enter"
                                    className="flex-1 px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-red-500 outline-none text-slate-900 font-mono"
                                />
                                <button
                                    onClick={() => {
                                        if (manualCode.trim()) {
                                            handleManualSearch({ key: 'Enter' });
                                        }
                                    }}
                                    className="bg-red-600 text-white px-6 py-2 rounded-lg font-bold hover:bg-red-700 active:scale-95 transition-transform"
                                >
                                    Buscar
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Video de la cámara */}
                    <div className="flex-1 relative overflow-hidden">
                        <video
                            id="scanner-video"
                            ref={videoRef}
                            className="w-full h-full object-cover"
                            playsInline
                            muted
                        />
                        
                        {/* Área para modo manual */}
                        {!isAutoMode && (
                            <div
                                className="absolute inset-0 z-20 touch-none"
                                onTouchStart={handlePressStart}
                                onTouchEnd={handlePressEnd}
                                onMouseDown={handlePressStart}
                                onMouseUp={handlePressEnd}
                                onMouseLeave={handlePressEnd}
                                style={{ 
                                    backgroundColor: isPressed ? 'rgba(239, 68, 68, 0.1)' : 'transparent',
                                    cursor: 'pointer'
                                }}
                            >
                                {isPressed && (
                                    <div className="absolute inset-0 flex items-center justify-center">
                                        <div className="bg-red-600/20 border-4 border-red-600 rounded-full w-32 h-32 flex items-center justify-center animate-pulse">
                                            <Icons.Scanner className="text-white" width="48" height="48" />
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Overlay de guía - ventana de lectura central */}
                        <div className="absolute inset-0 z-10 pointer-events-none">
                            <div className="absolute inset-0 flex items-center justify-center">
                                {isDetecting ? (
                                    <div className="border-4 border-green-500 rounded-lg w-64 h-64 shadow-2xl bg-green-500/30 animate-pulse">
                                        <div className="absolute inset-0 flex items-center justify-center">
                                            <div className="bg-green-500 text-white px-4 py-2 rounded-lg font-bold text-sm shadow-lg">
                                                ✓ {scannedCode ? 'Escaneado!' : 'Detectando...'}
                                            </div>
                                        </div>
                                    </div>
                                ) : (
                                    <div className={`border-2 ${isAutoMode ? 'border-yellow-400' : 'border-white/50'} rounded-lg w-64 h-64 shadow-lg`}>
                                        {isAutoMode && (
                                            <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-yellow-400 text-black px-3 py-1 rounded-full text-xs font-bold">
                                                Modo Automático
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            {/* Instrucciones */}
                            {!isAutoMode && (
                                <div className="absolute bottom-24 left-0 right-0 flex justify-center">
                                    <div className="bg-black/70 text-white px-4 py-2 rounded-lg text-sm font-bold">
                                        Presiona para escanear
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Pantalla de inicio */}
                    {!isCameraActive && (
                        <div className="absolute inset-0 z-10 bg-black/90 flex items-center justify-center pointer-events-none">
                            <div className="text-center text-white p-6">
                                <Icons.Scanner className="mx-auto mb-4" width="64" height="64" />
                                <p className="text-lg font-bold mb-2">Escáner QR / Código de Barras</p>
                                <p className="text-sm text-slate-300 mb-4">Presiona para activar la cámara</p>
                                <div className="mt-4 space-y-2 text-xs text-slate-400">
                                    <p>• Modo automático: escanea continuamente</p>
                                    <p>• Modo manual: presiona para escanear</p>
                                    <p>• Ingresa código manualmente abajo</p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- COMPONENTE DE ZONA POLIGONAL ---
        const PolygonZone = ({ zone, isEditMode, onUpdate, onClick, isAudited, onDelete, isDebugMode, addLog, isHighlighted, isPending, isDeleting, isSelected, onSelect }) => {
            const polygonRef = React.useRef(null);
            const [isDragging, setIsDragging] = React.useState(false);
            const [dragOffset, setDragOffset] = React.useState({ x: 0, y: 0 });
            
            const getColors = () => {
                if (isEditMode || isSelected) return { fill: 'rgba(59, 130, 246, 0.3)', stroke: 'rgba(59, 130, 246, 0.8)' };
                if (isDeleting) return { fill: 'rgba(239, 68, 68, 0.6)', stroke: 'rgba(220, 38, 38, 0.9)' };
                if (isPending) return { fill: 'rgba(59, 130, 246, 0.6)', stroke: 'rgba(37, 99, 235, 0.9)' };
                if (isAudited) return { fill: 'rgba(34, 197, 94, 0.6)', stroke: 'rgba(22, 163, 74, 0.9)' };
                return { fill: 'rgba(255, 255, 255, 0.05)', stroke: isDebugMode ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 0, 255, 0.1)' };
            };
            
            const colors = getColors();
            const pointsString = zone.points.map(p => `${p.x},${p.y}`).join(' ');
            
            const handleClick = (e) => {
                e.stopPropagation();
                // Si estamos creando un polígono nuevo, no procesar clics en polígonos existentes
                // (esto se maneja en handlePlaneClick)
                if (isEditMode && onSelect) {
                    onSelect(zone.id);
                } else if (!isEditMode) {
                    onClick(zone.name);
                }
            };
            
            // Manejar toques nativos para móviles (similar a InteractiveZone)
            React.useEffect(() => {
                const element = polygonRef.current;
                if (!element || isEditMode) return;

                let startX = 0;
                let startY = 0;
                let startTime = 0;
                let isDrag = false;

                const onTouchStart = (e) => {
                    if (e.touches.length > 1) return;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                    isDrag = false;
                };

                const onTouchMove = (e) => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    if (Math.abs(x - startX) > 15 || Math.abs(y - startY) > 15) {
                        isDrag = true;
                    }
                };

                const onTouchEnd = (e) => {
                    const timeDiff = Date.now() - startTime;
                    if (!isDrag && timeDiff < 500) {
                        if(e.cancelable) e.preventDefault();
                        e.stopPropagation();
                        if (isDebugMode && addLog) addLog(`NATIVE TAP POLYGON: ${zone.name}`);
                        onClick(zone.name);
                    }
                };

                element.addEventListener('touchstart', onTouchStart, { passive: true });
                element.addEventListener('touchmove', onTouchMove, { passive: true });
                element.addEventListener('touchend', onTouchEnd, { passive: false });

                return () => {
                    element.removeEventListener('touchstart', onTouchStart);
                    element.removeEventListener('touchmove', onTouchMove);
                    element.removeEventListener('touchend', onTouchEnd);
                };
            }, [isEditMode, onClick, zone.name, isDebugMode, addLog]);
            
            return (
                <g ref={polygonRef} onClick={handleClick} style={{ cursor: isEditMode ? 'move' : 'pointer', pointerEvents: 'auto' }}>
                    <polygon
                        points={pointsString}
                        fill={colors.fill}
                        stroke={isHighlighted ? 'red' : colors.stroke}
                        strokeWidth={isHighlighted ? 3 : 2}
                        opacity={isHighlighted ? 0.8 : 1}
                        style={{ pointerEvents: 'auto' }}
                    />
                    {isEditMode && (
                        <>
                            <text x={zone.points[0].x} y={zone.points[0].y - 5} fontSize="8" fill="white" fontWeight="bold" style={{ pointerEvents: 'none' }}>
                                {zone.name}
                            </text>
                            <circle cx={zone.points[0].x} cy={zone.points[0].y} r="4" fill="red" onClick={(e) => { e.stopPropagation(); onDelete(zone.id); }} />
                        </>
                    )}
                </g>
            );
        };
        
        // --- COMPONENTE DE CAJA INTERACTIVA (ZONA) ---
        const InteractiveZone = ({ zone, isEditMode, onUpdate, onClick, isAudited, onDelete, isDebugMode, addLog, isHighlighted, isPending, isDeleting, isSelected, onSelect, isEditorModeActive }) => {
            const boxRef = React.useRef(null);
            const [isDragging, setIsDragging] = React.useState(false);
            const [dragOffset, setDragOffset] = React.useState({ x: 0, y: 0 });
            
            // COLORES
            const getColors = () => {
                if (isEditMode) return { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.8)' };
                if (isDeleting) return { bg: 'rgba(239, 68, 68, 0.6)', border: 'rgba(220, 38, 38, 0.9)' }; // ROJO (Eliminando)
                if (isPending) return { bg: 'rgba(59, 130, 246, 0.6)', border: 'rgba(37, 99, 235, 0.9)' }; // AZUL (En Cola)
                if (isAudited) return { bg: 'rgba(34, 197, 94, 0.6)', border: 'rgba(22, 163, 74, 0.9)' }; // VERDE (Guardado)
                // En modo debug o normal, aseguramos visibilidad mínima para que el usuario sepa dónde tocar
                return { bg: 'rgba(255, 255, 255, 0.05)', border: isDebugMode ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 0, 255, 0.1)' }; 
            };
            const colors = getColors();

            const startDrag = (e) => {
                // Solo permitir arrastre cuando realmente se está editando
                if (!isEditMode) {
                    // No hacer nada, permitir que el onClick maneje el evento
                    return;
                }
                e.stopPropagation(); 
                e.preventDefault(); // Prevenir comportamiento por defecto solo en modo edición
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setIsDragging(true);
                setDragOffset({ x: clientX - zone.x, y: clientY - zone.y });
            };

            const startResize = (e) => {
                if (!isEditMode) return;
                e.stopPropagation();
                const startX = e.touches ? e.touches[0].clientX : e.clientX;
                const startY = e.touches ? e.touches[0].clientY : e.clientY;
                const startWidth = zone.w;
                const startHeight = zone.h;
                const onMove = (moveEvent) => {
                    const currentX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const currentY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    onUpdate(zone.id, { w: Math.max(10, startWidth + (currentX - startX)), h: Math.max(10, startHeight + (currentY - startY)) });
                };
                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
            };

            const startRotate = (e) => {
                if (!isEditMode) return;
                e.stopPropagation();
                e.preventDefault();
                const boxRect = boxRef.current.getBoundingClientRect();
                const centerX = boxRect.left + boxRect.width / 2;
                const centerY = boxRect.top + boxRect.height / 2;
                const onMove = (moveEvent) => {
                    const currentX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const currentY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    const angleRad = Math.atan2(currentY - centerY, currentX - centerX);
                    onUpdate(zone.id, { r: (angleRad * (180 / Math.PI)) + 90 });
                };
                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
            };

            React.useEffect(() => {
                if (!isDragging) return;
                const onMove = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    onUpdate(zone.id, { x: clientX - dragOffset.x, y: clientY - dragOffset.y });
                };
                const onEnd = () => setIsDragging(false);
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
                return () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
            }, [isDragging, dragOffset, onUpdate, zone.id]);

            // --- MANEJADORES DE TOQUE NATIVOS (SOLUCIÓN DEFINITIVA) ---
            React.useEffect(() => {
                const element = boxRef.current;
                // Solo deshabilitar toques cuando realmente se está editando, no solo cuando el modo editor está activo
                if (!element || isEditMode) return;

                let startX = 0;
                let startY = 0;
                let startTime = 0;
                let isDrag = false;

                const onTouchStart = (e) => {
                    if (e.touches.length > 1) return; // Ignorar zoom multitouch
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                    isDrag = false;
                    // NO detenemos propagación aquí para permitir que el mapa reciba el evento y decida si hacer scroll
                };

                const onTouchMove = (e) => {
                    const x = e.touches[0].clientX;
                    const y = e.touches[0].clientY;
                    // Si se mueve más de 15px, asumimos que es un arrastre de mapa, no un clic
                    if (Math.abs(x - startX) > 15 || Math.abs(y - startY) > 15) {
                        isDrag = true;
                    }
                };

                const onTouchEnd = (e) => {
                    const timeDiff = Date.now() - startTime;
                    // Si no fue un arrastre largo y el toque fue rápido (<500ms)
                    if (!isDrag && timeDiff < 500) {
                        // Es un TAP válido
                        if(e.cancelable) e.preventDefault(); // Prevenir comportamientos del navegador
                        e.stopPropagation(); // Detener para que el mapa no intente hacer nada más
                        
                        if (isDebugMode) addLog(`NATIVE TAP: ${zone.name}`);
                        onClick(zone.name);
                    }
                };

                // Añadimos listeners nativos NO pasivos para poder llamar preventDefault si es necesario
                element.addEventListener('touchstart', onTouchStart, { passive: true });
                element.addEventListener('touchmove', onTouchMove, { passive: true });
                element.addEventListener('touchend', onTouchEnd, { passive: false });

                return () => {
                    element.removeEventListener('touchstart', onTouchStart);
                    element.removeEventListener('touchmove', onTouchMove);
                    element.removeEventListener('touchend', onTouchEnd);
                };
            }, [isEditMode, onClick, zone.name, isDebugMode, addLog]);

            return (
                <div ref={boxRef} 
                    className={`interactive-zone transition-colors-fast ${isHighlighted ? 'highlight-zone' : ''}`}
                    onMouseDown={(e) => {
                        // Solo manejar arrastre si estamos en modo edición
                        if (isEditMode) {
                            startDrag(e);
                        }
                        // Si no estamos editando, no hacer nada - permitir que onClick maneje el evento
                    }}
                    onClick={(e) => { 
                        // Clic para escritorio (mouse)
                        e.stopPropagation(); 
                        e.preventDefault();
                        
                        // Si estamos arrastrando, no procesar el clic
                        if (isDragging) {
                            return;
                        }
                        
                        // Debug: verificar qué está pasando
                        console.log('Zone clicked:', zone.name, 'isEditMode:', isEditMode, 'isEditorModeActive:', isEditorModeActive, 'onClick:', !!onClick);
                        
                        // PRIORIDAD 1: Si está en modo edición Y el modo editor está activo, permitir selección
                        if(isEditMode && onSelect && isEditorModeActive) {
                            console.log('Selecting zone:', zone.id);
                            onSelect(zone.id);
                            return;
                        }
                        
                        // PRIORIDAD 2: En cualquier otro caso (no editando), SIEMPRE permitir clic normal para abrir auditoría
                        console.log('Calling onClick for zone:', zone.name);
                        if(isDebugMode && addLog) {
                            addLog(`Mouse Click: ${zone.name}`);
                        }
                        if(onClick) {
                            onClick(zone.name);
                        } else {
                            console.error('onClick is not defined!');
                        }
                    }}
                    style={{ 
                        position: 'absolute', 
                        left: zone.x, 
                        top: zone.y, 
                        width: zone.w, 
                        height: zone.h, 
                        transform: `rotate(${zone.r || 0}deg)`, 
                        transformOrigin: 'center center', 
                        border: isSelected ? '3px solid yellow' : (isHighlighted ? '3px solid red' : `2px solid ${colors.border}`), 
                        backgroundColor: isHighlighted ? 'rgba(255,0,0,0.3)' : colors.bg, 
                        cursor: isEditMode ? 'move' : 'pointer', 
                        zIndex: isHighlighted ? 30 : 20, // Aumentar z-index para estar por encima del SVG 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center', 
                        boxSizing: 'border-box' 
                    }}
                >
                    <span className={`px-1 text-[8px] font-bold pointer-events-none select-none truncate max-w-full ${isEditMode ? 'bg-white/80' : 'hidden'}`}>{zone.name}</span>
                    {isEditMode && (
                        <>
                            <button onClick={(e) => { e.stopPropagation(); onDelete(zone.id); }} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full flex items-center justify-center shadow-md z-30" style={{width: '12px', height: '12px', fontSize: '8px', lineHeight: '10px'}}>✕</button>
                            <div className="resize-handle" onMouseDown={startResize} onTouchStart={startResize} />
                            <div className="rotate-line"></div>
                            <div className="rotate-handle" onMouseDown={startRotate} onTouchStart={startRotate} />
                        </>
                    )}
                </div>
            );
        };

        const MapEditor = ({ onLocationClick, auditedLocations, locationsList, isDebugMode, addLog, auditLog, focusTarget, pendingLocations, deletingLocations, currentUser, currentView, setCurrentView, isEditorMode, setIsEditorMode, isSelectingLocationFromMap }) => {
            // Asegurar que currentView tenga un valor por defecto
            const view = currentView || 'PLANO';
            
            // Determinar imagen según la vista actual
            // PLANO: imagen del plano original
            // PLANOGRAMA: imagen del planograma
            const mapImageUrl = (view === "PLANOGRAMA") 
                ? "https://i.imgur.com/Yuiv4JC.jpeg" 
                : "https://i.imgur.com/VRncOKx.jpeg";
            
            // Inicializar zonas - empezar con INITIAL_ZONES por defecto
            const [zones, setZones] = React.useState(INITIAL_ZONES);
            
            // Recargar zonas cuando cambie la vista
            React.useEffect(() => {
                const view = currentView || 'PLANO';
                
                if (view === "PLANOGRAMA") {
                    // Para PLANOGRAMA, cargar desde localStorage o usar INITIAL_ZONES_PLANOGRAMA
                    const stored = localStorage.getItem(`zones_PLANOGRAMA`);
                    if (stored) {
                        try {
                            setZones(JSON.parse(stored));
                        } catch (e) {
                            console.error('Error parsing PLANOGRAMA zones:', e);
                            setZones(INITIAL_ZONES_PLANOGRAMA);
                        }
                    } else {
                        setZones(INITIAL_ZONES_PLANOGRAMA);
                    }
                } else {
                    // Para PLANO, usar INITIAL_ZONES
                    setZones(INITIAL_ZONES);
                }
            }, [currentView]);
            const [isEditMode, setIsEditMode] = React.useState(false); 
            const [isPlacingMode, setIsPlacingMode] = React.useState(false);
            const [isAddZoneModalOpen, setIsAddZoneModalOpen] = React.useState(false);
            const [newZoneName, setNewZoneName] = React.useState("");
            const [newZoneW, setNewZoneW] = React.useState(40);
            const [newZoneH, setNewZoneH] = React.useState(40);
            const [tempClickCoords, setTempClickCoords] = React.useState({x:0, y:0});
            const [isCopyModalOpen, setIsCopyModalOpen] = React.useState(false);
            const [zonesJson, setZonesJson] = React.useState("");
            const [isGlobalEditMode, setIsGlobalEditMode] = React.useState(false);
            // isEditorMode ahora viene como prop desde el componente principal
            const [selectedZoneId, setSelectedZoneId] = React.useState(null);
            const [isPolygonMode, setIsPolygonMode] = React.useState(false);
            const [polygonPoints, setPolygonPoints] = React.useState([]);
            const [isAddingPolygon, setIsAddingPolygon] = React.useState(false);
            const mapContainerRef = React.useRef(null);
            const panzoomInstance = React.useRef(null);
            const imageRef = React.useRef(null);
            
            // Guardar zonas en localStorage cuando cambien (solo para PLANOGRAMA)
            React.useEffect(() => {
                const view = currentView || 'PLANO';
                if (view === "PLANOGRAMA" && zones.length > 0) {
                    try {
                        localStorage.setItem(`zones_PLANOGRAMA`, JSON.stringify(zones));
                    } catch (e) {
                        console.error('Error saving PLANOGRAMA zones:', e);
                    }
                }
            }, [zones, currentView]);
            
            // Atajo de teclado CTRL+SHIFT+E para activar modo editor (solo ADMIN) - OPCIONAL, también funciona el botón
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'E') {
                        e.preventDefault();
                        if (currentUser && currentUser.toUpperCase() === 'ADMIN' && setIsEditorMode) {
                            setIsEditorMode(prev => !prev);
                            if (!isEditorMode) {
                                setIsEditMode(true); // Activar también el modo de edición de zonas
                            }
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentUser, isEditorMode, setIsEditorMode]);
            
            // Activar modo de edición de zonas cuando se activa el modo editor
            React.useEffect(() => {
                if (isEditorMode) {
                    setIsEditMode(true);
                }
            }, [isEditorMode]);

            // --- ESTADOS PARA BÚSQUEDA AVANZADA EN MAPA ---
            const [isSearchModalOpen, setIsSearchModalOpen] = React.useState(false);
            const [searchType, setSearchType] = React.useState('product'); // Default to product as requested
            const [mapSearchQuery, setMapSearchQuery] = React.useState('');
            const [highlightedZones, setHighlightedZones] = React.useState([]);

            // Función para centrar en una zona (ACTUALIZADA: ZOOM 1/6)
            const centerOnZone = (zoneName) => {
                 if (panzoomInstance.current && mapContainerRef.current) {
                    const targetZone = zones.find(z => z.name === zoneName);
                    if (targetZone) {
                        const parent = mapContainerRef.current.parentElement.getBoundingClientRect();
                        const containerWidth = parent.width;
                        const containerHeight = parent.height;
                        
                        // 1. Calcular escala objetivo (1/6 de la pantalla)
                        // Usamos la dimensión más pequeña de la pantalla y la más grande de la zona
                        const zoneSize = Math.max(targetZone.w, targetZone.h);
                        const screenSize = Math.min(containerWidth, containerHeight);
                        
                        // Fórmula: zoneSize * scale = screenSize / 6
                        let targetScale = (screenSize / 6) / zoneSize;
                        
                        // Limitar escala para evitar zooms extremos
                        targetScale = Math.min(Math.max(targetScale, 0.1), 8); // Max zoom 8x
                        
                        // 2. Calcular centro de la zona
                        const zoneCenterX = targetZone.x + targetZone.w / 2;
                        const zoneCenterY = targetZone.y + targetZone.h / 2;
                        
                        // 3. Calcular posición para centrar
                        // offset = CentroPantalla - (CentroZona * Escala)
                        const newX = (containerWidth / 2) - (zoneCenterX * targetScale);
                        const newY = (containerHeight / 2) - (zoneCenterY * targetScale);

                        // 4. Aplicar (Zoom primero, luego mover)
                        // zoomAbs(0, 0, scale) escala relativo al origen 0,0 del contenedor
                        panzoomInstance.current.zoomAbs(0, 0, targetScale);
                        panzoomInstance.current.moveTo(newX, newY);
                    }
                }
            };

            // Manejar foco externo (desde lista/historial)
            React.useEffect(() => {
                if (focusTarget) {
                    setHighlightedZones([focusTarget.location]);
                    centerOnZone(focusTarget.location);
                }
            }, [focusTarget, zones]);

            // Identificar zonas resaltadas (búsqueda interna del mapa)
            React.useEffect(() => {
                if (highlightedZones.length > 0) {
                    centerOnZone(highlightedZones[0]);
                }
            }, [highlightedZones]);

            // Inicialización de Panzoom y centrado inicial (FIT TO SCREEN RESTAURADO)
            const handleImageLoad = () => {
                 if (mapContainerRef.current && panzoomInstance.current) {
                    // Esperar un momento para asegurar renderizado correcto
                    setTimeout(() => {
                        const img = imageRef.current;
                        if (!img) return;

                        const parent = mapContainerRef.current.parentElement;
                        if (!parent) return;

                        const parentRect = parent.getBoundingClientRect();
                        // Usamos dimensions naturales o si la imagen tiene width/height definido en CSS
                        const contentWidth = img.naturalWidth || img.width; 
                        const contentHeight = img.naturalHeight || img.height;

                        if (contentWidth === 0 || contentHeight === 0) return;

                        // Calculate scale to fit width or height (Fit-to-Screen Logic)
                        const scaleX = parentRect.width / contentWidth;
                        const scaleY = parentRect.height / contentHeight;
                        
                        // Usar escala menor para asegurar fit, con margen 5%
                        const initialScale = Math.min(scaleX, scaleY) * 0.95; 

                        // Center logic
                        const initialX = (parentRect.width - contentWidth * initialScale) / 2;
                        const initialY = (parentRect.height - contentHeight * initialScale) / 2;

                        // Apply transform manually first time to ensure correct positioning
                        panzoomInstance.current.zoomAbs(0, 0, initialScale);
                        panzoomInstance.current.moveTo(initialX, initialY);

                    }, 100);
                }
            }

            React.useEffect(() => {
                if (mapContainerRef.current) {
                    panzoomInstance.current = panzoom(mapContainerRef.current, { 
                        maxZoom: 10, 
                        minZoom: 0.1, 
                        initialZoom: 1,
                        bounds: false, // Permitir mover libremente para centrar bien
                        //boundsPadding: 0.1,
                        filterKey: function() { return true; }, 
                        onTouch: function(e) { return true; } 
                    });
                }
                return () => panzoomInstance.current && panzoomInstance.current.dispose();
            }, []);

            // Solo pausar panzoom cuando se está editando zonas específicas, no cuando solo está activo el modo editor
            // Esto permite mover/acercar/alejar el plano incluso en modo editor
            React.useEffect(() => { 
                if(panzoomInstance.current) {
                    // Solo pausar si estamos en modo de edición de zonas o moviendo todas las zonas
                    // NO pausar solo por estar en modo editor, para permitir navegación del plano
                    if (isEditMode || isGlobalEditMode) {
                        panzoomInstance.current.pause();
                    } else {
                        panzoomInstance.current.resume();
                    }
                }
            }, [isEditMode, isGlobalEditMode]);

            const startPlacement = () => setIsPlacingMode(true);

            const handlePlaneClick = (e) => {
                // Si estamos en modo polígono, agregar punto (solo si no se hizo clic en un polígono existente)
                if (isPolygonMode && isAddingPolygon) {
                    // Verificar si el clic fue en un polígono existente
                    const target = e.target;
                    if (target && (target.tagName === 'polygon' || target.closest('g')?.querySelector('polygon'))) {
                        // Si se hizo clic en un polígono, no agregar punto, dejar que el polígono maneje el clic
                        return;
                    }
                    const rect = mapContainerRef.current.getBoundingClientRect();
                    const scale = panzoomInstance.current.getTransform().scale;
                    const x = (e.clientX - rect.left) / scale;
                    const y = (e.clientY - rect.top) / scale;
                    setPolygonPoints([...polygonPoints, { x, y }]);
                    return;
                }
                
                if (!isPlacingMode) return;
                const rect = mapContainerRef.current.getBoundingClientRect();
                const scale = panzoomInstance.current.getTransform().scale;
                const x = (e.clientX - rect.left) / scale;
                const y = (e.clientY - rect.top) / scale;
                setTempClickCoords({x, y});
                setIsPlacingMode(false);
                setNewZoneName(""); setNewZoneW(40); setNewZoneH(40);
                setIsAddZoneModalOpen(true);
            };

            const confirmAddZone = () => {
                if (!newZoneName.trim()) return;
                // Si hay puntos de polígono, crear polígono
                if (polygonPoints.length >= 3) {
                    confirmAddPolygonZone();
                    return;
                }
                // Si no, crear zona rectangular normal
                const newZone = { id: Date.now(), name: newZoneName, x: tempClickCoords.x - (newZoneW/2), y: tempClickCoords.y - (newZoneH/2), w: parseInt(newZoneW), h: parseInt(newZoneH), r: 0, type: 'rect' };
                setZones([...zones, newZone]);
                setIsAddZoneModalOpen(false);
            };
            
            // Iniciar creación de polígono
            const startPolygonCreation = () => {
                setPolygonPoints([]);
                setIsPolygonMode(true);
                setIsAddingPolygon(true);
                setIsPlacingMode(false);
            };

            const updateZone = (id, newProps) => setZones(zones.map(z => z.id === id ? { ...z, ...newProps } : z));
            const deleteZone = (id) => { if(confirm("¿Borrar esta zona?")) setZones(zones.filter(z => z.id !== id)); };
            
            // Función para manejar clic en zona - si es CHIQUILLADAS, cambiar a vista PLANOGRAMA
            const handleZoneClick = (zoneName) => {
                const upperName = zoneName.toUpperCase();
                
                // Si estamos en modo selección desde mapa (para el escáner)
                if (isSelectingLocationFromMap) {
                    // CHIQUILLADAS y MUESTRARIO NO son seleccionables, solo cambian la vista
                    if (upperName === "CHIQUILLADAS" || upperName === "MUESTRARIO") {
                        // Cambiar a vista PLANOGRAMA sin seleccionar como ubicación
                        if (setCurrentView) {
                            setCurrentView("PLANOGRAMA");
                        } else {
                            console.error('setCurrentView no está definido');
                        }
                        return; // No seleccionar, solo cambiar vista
                    }
                    // Para otras zonas, seleccionar como ubicación
                    onLocationClick(zoneName);
                    return;
                }
                
                // Comportamiento normal cuando NO estamos en modo selección
                if (upperName === "CHIQUILLADAS" || upperName === "MUESTRARIO") {
                    // Cambiar a vista PLANOGRAMA sin recargar la página
                    if (setCurrentView) {
                        setCurrentView("PLANOGRAMA");
                    } else {
                        console.error('setCurrentView no está definido');
                    }
                } else {
                    // Para otras zonas, abrir modal de auditoría
                    onLocationClick(zoneName);
                }
            };
            
            // Función para finalizar polígono
            const finishPolygon = () => {
                if (polygonPoints.length < 3) {
                    alert("Un polígono necesita al menos 3 puntos");
                    return;
                }
                setIsAddingPolygon(false);
                setIsPolygonMode(false);
                setNewZoneName("");
                setIsAddZoneModalOpen(true);
            };
            
            // Función para cancelar polígono
            const cancelPolygon = () => {
                setPolygonPoints([]);
                setIsAddingPolygon(false);
                setIsPolygonMode(false);
            };
            
            // Función para crear zona poligonal
            const confirmAddPolygonZone = () => {
                if (!newZoneName.trim() || polygonPoints.length < 3) return;
                const newZone = { 
                    id: Date.now(), 
                    name: newZoneName, 
                    type: 'polygon',
                    points: polygonPoints,
                    r: 0 
                };
                setZones([...zones, newZone]);
                setPolygonPoints([]);
                setIsAddZoneModalOpen(false);
            };

            const startGlobalDrag = (e) => {
                e.stopPropagation();
                e.preventDefault();
                const startX = e.touches ? e.touches[0].clientX : e.clientX;
                const startY = e.touches ? e.touches[0].clientY : e.clientY;
                const initialZones = zones.map(z => ({...z}));
                const onMove = (moveEvent) => {
                    const currentX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const currentY = moveEvent.touches ? moveEvent.touches[0].clientY : moveEvent.clientY;
                    const scale = panzoomInstance.current.getTransform().scale;
                    const dx = (currentX - startX) / scale;
                    const dy = (currentY - startY) / scale;
                    setZones(initialZones.map(z => ({...z, x: z.x + dx, y: z.y + dy})));
                };
                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
            };

            const startGlobalResize = (e) => {
                e.stopPropagation();
                e.preventDefault();
                const startX = e.touches ? e.touches[0].clientX : e.clientX;
                const xValues = zones.map(z => z.x);
                const minY = Math.min(...zones.map(z => z.y));
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues.map((v, i) => v + zones[i].w));
                const initialWidth = maxX - minX;
                const initialZones = zones.map(z => ({...z}));
                const onMove = (moveEvent) => {
                    const currentX = moveEvent.touches ? moveEvent.touches[0].clientX : moveEvent.clientX;
                    const scale = panzoomInstance.current.getTransform().scale;
                    const diffX = (currentX - startX) / scale;
                    const scaleFactor = (initialWidth + diffX) / initialWidth;
                    if(scaleFactor > 0.1) {
                        setZones(initialZones.map(z => ({
                            ...z,
                            x: minX + (z.x - minX) * scaleFactor,
                            y: minY + (z.y - minY) * scaleFactor,
                            w: z.w * scaleFactor,
                            h: z.h * scaleFactor
                        })));
                    }
                };
                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
            };

            const getGroupBounds = () => {
                if (zones.length === 0) return { x: 0, y: 0, w: 0, h: 0 };
                const minX = Math.min(...zones.map(z => z.x));
                const minY = Math.min(...zones.map(z => z.y));
                const maxX = Math.max(...zones.map(z => z.x + z.w));
                const maxY = Math.max(...zones.map(z => z.y + z.h));
                return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
            };
            const groupBounds = getGroupBounds();

            const exportZones = () => {
                const json = JSON.stringify(zones, null, 2);
                setZonesJson(json);
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = json; textArea.style.position = "fixed"; textArea.style.left = "-9999px";
                    document.body.appendChild(textArea); textArea.select();
                    const successful = document.execCommand('copy'); document.body.removeChild(textArea);
                    if (successful) return alert("¡Copiado! Pégalo en INITIAL_ZONES.");
                } catch (err) {}
                setIsCopyModalOpen(true);
            };
            
            // --- Lógica del Modal de Búsqueda ---
            const handleSearchSubmit = (val) => {
                setMapSearchQuery(val);
                setIsSearchModalOpen(false);
                
                // Siempre buscar producto (punto 2: quitar búsqueda de lugar, ir directo a producto)
                // Buscar todas las zonas que tengan ese producto
                const zonesWithProduct = auditLog
                    .filter(entry => getProductName(entry.product) === val)
                    .map(entry => entry.location);
                
                if (zonesWithProduct.length > 0) {
                    setHighlightedZones(zonesWithProduct);
                } else {
                    alert("Este producto no está en ninguna ubicación auditada.");
                    setHighlightedZones([]);
                }
                setMapSearchQuery('');
            };

            const uniqueProducts = React.useMemo(() => [...new Set(auditLog.map(item => item.product))].sort(), [auditLog]);

            // Handler para abrir búsqueda directa
            const openSearch = () => {
                setSearchType('product'); // Forzar tipo producto
                setIsSearchModalOpen(true);
            };


            return (
                <div className="flex flex-col h-full bg-neutral-50 relative overflow-hidden">
                    {/* Barra de herramientas del modo editor (solo visible si isEditorMode está activo) */}
                    {isEditorMode && (
                        <div className="absolute top-4 left-4 right-4 z-20 flex gap-2 justify-between pointer-events-none">
                            <div className="flex gap-2 pointer-events-auto">
                                <button onClick={() => setIsEditorMode(false)} className="p-3 rounded-full shadow-lg font-bold flex items-center gap-2 transition-colors bg-red-600 text-white">
                                    <Icons.X /> Salir Editor
                                </button>
                                <button onClick={() => setIsEditMode(!isEditMode)} className={`p-3 rounded-full shadow-lg font-bold flex items-center gap-2 transition-colors ${isEditMode ? 'bg-yellow-400 text-black' : 'bg-white text-slate-700'}`}>
                                    {isEditMode ? <Icons.Unlock /> : <Icons.Lock />} {isEditMode ? 'Editando' : 'Navegando'}
                                </button>
                                {isEditMode && (
                                    <button 
                                        onClick={() => setIsGlobalEditMode(!isGlobalEditMode)} 
                                        className={`p-3 rounded-full shadow-lg font-bold flex items-center gap-2 transition-colors ${isGlobalEditMode ? 'bg-black text-white' : 'bg-white text-black'}`}
                                        title="Mover/Escalar Todos"
                                    >
                                        <Icons.GroupSelect />
                                    </button>
                                )}
                            </div>
                            {isEditMode && (
                                <div className="flex gap-2 pointer-events-auto">
                                    <button onClick={startPlacement} className={`p-3 rounded-full shadow-lg hover:bg-neutral-800 flex items-center gap-1 text-white ${isPlacingMode ? 'bg-green-600 animate-pulse' : 'bg-black'}`}>
                                        <Icons.Plus /> {isPlacingMode ? 'Toca mapa' : 'Zona Rect'}
                                    </button>
                                    <button onClick={startPolygonCreation} className={`p-3 rounded-full shadow-lg hover:bg-purple-700 flex items-center gap-1 text-white ${isPolygonMode ? 'bg-purple-600 animate-pulse' : 'bg-purple-800'}`}>
                                        <Icons.Plus /> {isPolygonMode ? 'Agregando...' : 'Zona Polígono'}
                                    </button>
                                    {isPolygonMode && polygonPoints.length >= 2 && (
                                        <>
                                            <button onClick={finishPolygon} className="p-3 rounded-full shadow-lg bg-green-600 text-white hover:bg-green-700">
                                                Finalizar
                                            </button>
                                            <button onClick={cancelPolygon} className="p-3 rounded-full shadow-lg bg-red-600 text-white hover:bg-red-700">
                                                Cancelar
                                            </button>
                                        </>
                                    )}
                                    {selectedZoneId && (
                                        <button onClick={() => { if(confirm("¿Eliminar zona seleccionada?")) deleteZone(selectedZoneId); setSelectedZoneId(null); }} className="p-3 rounded-full shadow-lg bg-red-600 text-white hover:bg-red-700">
                                            <Icons.Trash />
                                        </button>
                                    )}
                                    <button onClick={exportZones} className="bg-red-600 text-white p-3 rounded-full shadow-lg hover:bg-red-700"><Icons.Save /></button>
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* Indicador de modo editor */}
                    {isEditorMode && (
                        <div className="absolute top-20 left-0 right-0 flex justify-center z-30 pointer-events-none">
                            <div className="bg-yellow-500 text-black px-4 py-2 rounded-full text-sm font-bold shadow-xl">
                                MODO EDITOR ACTIVO - {isPlacingMode ? 'Toca en el mapa donde quieras el botón' : (isPolygonMode ? `Agregando polígono (${polygonPoints.length} puntos) - Toca para agregar punto, Finalizar para terminar` : 'Selecciona zonas para editarlas')}
                            </div>
                        </div>
                    )}
                    
                    {/* Barra de herramientas antigua (solo si no está en modo editor) */}
                    {!isEditorMode && (
                        <div className={`absolute top-4 left-4 right-4 z-20 flex gap-2 justify-between pointer-events-none ${isEditMode ? '' : 'hidden'}`}>
                            <div className="flex gap-2 pointer-events-auto">
                                <button onClick={() => setIsEditMode(!isEditMode)} className={`p-3 rounded-full shadow-lg font-bold flex items-center gap-2 transition-colors ${isEditMode ? 'bg-yellow-400 text-black' : 'bg-white text-slate-700'}`}>
                                    {isEditMode ? <Icons.Unlock /> : <Icons.Lock />} {isEditMode ? 'Editando' : 'Navegando'}
                                </button>
                                {isEditMode && (
                                    <button 
                                        onClick={() => setIsGlobalEditMode(!isGlobalEditMode)} 
                                        className={`p-3 rounded-full shadow-lg font-bold flex items-center gap-2 transition-colors ${isGlobalEditMode ? 'bg-black text-white' : 'bg-white text-black'}`}
                                        title="Mover/Escalar Todos"
                                    >
                                        <Icons.GroupSelect />
                                    </button>
                                )}
                            </div>
                            {isEditMode && (
                                <div className="flex gap-2 pointer-events-auto">
                                    <button onClick={startPlacement} className={`p-3 rounded-full shadow-lg hover:bg-neutral-800 flex items-center gap-1 text-white ${isPlacingMode ? 'bg-green-600 animate-pulse' : 'bg-black'}`}>
                                        <Icons.Plus /> {isPlacingMode ? 'Toca mapa' : 'Zona'}
                                    </button>
                                    <button onClick={exportZones} className="bg-red-600 text-white p-3 rounded-full shadow-lg hover:bg-red-700"><Icons.Save /></button>
                                </div>
                            )}
                        </div>
                    )}
                    {isPlacingMode && !isEditorMode && <div className="absolute top-20 left-0 right-0 flex justify-center z-30 pointer-events-none"><div className="bg-black/70 text-white px-4 py-2 rounded-full text-sm font-bold shadow-xl">Toca en el mapa donde quieras el botón</div></div>}
                    
                    <div className="absolute inset-0 bg-slate-100 overflow-hidden active:cursor-grabbing prevent-browser-zoom">
                        <div ref={mapContainerRef} onClick={handlePlaneClick} className="relative shadow-2xl bg-white" style={{ width: 'max-content', height: 'max-content', transformOrigin: '0 0' }}>
                            <img 
                                ref={imageRef}
                                src={mapImageUrl} 
                                alt="Plano" 
                                className="pointer-events-none select-none block" 
                                draggable="false" 
                                style={{ maxWidth: 'none', display: 'block' }} 
                                onLoad={handleImageLoad}
                            />
                            
                            {isGlobalEditMode && isEditMode && (
                                <div 
                                    onMouseDown={startGlobalDrag}
                                    onTouchStart={startGlobalDrag}
                                    style={{
                                        position: 'absolute', left: groupBounds.x, top: groupBounds.y, width: groupBounds.w, height: groupBounds.h,
                                        border: '2px dashed #9333ea', backgroundColor: 'rgba(147, 51, 234, 0.1)', zIndex: 40, cursor: 'move'
                                    }}
                                >
                                    <div className="group-resize-handle" onMouseDown={startGlobalResize} onTouchStart={startGlobalResize} />
                                </div>
                            )}

                            {/* Renderizar zonas rectangulares */}
                            {zones.filter(z => !z.type || z.type === 'rect').map(zone => (
                                <InteractiveZone 
                                    key={zone.id} 
                                    zone={zone} 
                                    isEditMode={isEditMode} 
                                    onUpdate={updateZone} 
                                    onClick={handleZoneClick} 
                                    isAudited={auditedLocations.includes(zone.name)} 
                                    onDelete={deleteZone} 
                                    isDebugMode={isDebugMode} 
                                    addLog={addLog} 
                                    isHighlighted={highlightedZones.includes(zone.name)} 
                                    isPending={pendingLocations.includes(zone.name)} 
                                    isDeleting={deletingLocations.includes(zone.name)}
                                    isSelected={selectedZoneId === zone.id}
                                    onSelect={setSelectedZoneId}
                                    isEditorModeActive={isEditorMode}
                                />
                            ))}
                            
                            {/* Renderizar zonas poligonales con SVG - posicionado absolutamente dentro del contenedor del mapa */}
                            {(() => {
                                const img = imageRef.current;
                                if (!img) return null;
                                const imgWidth = img.naturalWidth || img.width;
                                const imgHeight = img.naturalHeight || img.height;
                                return (
                                    <svg 
                                        style={{ 
                                            position: 'absolute', 
                                            top: 0, 
                                            left: 0, 
                                            width: imgWidth, 
                                            height: imgHeight, 
                                            pointerEvents: 'none', // Desactivar eventos en el contenedor SVG para no bloquear zonas rectangulares
                                            zIndex: 5 // Menor z-index que las zonas rectangulares (10)
                                        }}
                                    >
                                        {zones.filter(z => z.type === 'polygon').map(zone => (
                                            <PolygonZone
                                                key={zone.id}
                                                zone={zone}
                                                isEditMode={isEditMode}
                                                onUpdate={updateZone}
                                                onClick={handleZoneClick}
                                                isAudited={auditedLocations.includes(zone.name)}
                                                onDelete={deleteZone}
                                                isDebugMode={isDebugMode}
                                                addLog={addLog}
                                                isHighlighted={highlightedZones.includes(zone.name)}
                                                isPending={pendingLocations.includes(zone.name)}
                                                isDeleting={deletingLocations.includes(zone.name)}
                                                isSelected={selectedZoneId === zone.id}
                                                onSelect={setSelectedZoneId}
                                            />
                                        ))}
                                        
                                        {/* Mostrar puntos del polígono en construcción */}
                                        {isAddingPolygon && polygonPoints.map((point, idx) => (
                                            <g key={idx}>
                                                <circle cx={point.x} cy={point.y} r="5" fill="red" stroke="white" strokeWidth="2" style={{ pointerEvents: 'auto', cursor: 'pointer' }} />
                                                {idx > 0 && (
                                                    <line x1={polygonPoints[idx-1].x} y1={polygonPoints[idx-1].y} x2={point.x} y2={point.y} stroke="red" strokeWidth="2" strokeDasharray="5,5" />
                                                )}
                                                {idx === polygonPoints.length - 1 && polygonPoints.length >= 2 && (
                                                    <line x1={polygonPoints[0].x} y1={polygonPoints[0].y} x2={point.x} y2={point.y} stroke="red" strokeWidth="2" strokeDasharray="5,5" opacity="0.5" />
                                                )}
                                            </g>
                                        ))}
                                    </svg>
                                );
                            })()}
                        </div>
                    </div>
                    
                    {/* Botón Flotante de Búsqueda */}
                    <div className="absolute bottom-6 right-6 z-30 pointer-events-auto flex flex-col gap-2 items-end">
                         {highlightedZones.length > 0 && (
                            <button 
                                onClick={() => setHighlightedZones([])} 
                                className="bg-white text-red-500 font-bold p-3 rounded-full shadow-lg hover:bg-red-50"
                                title="Limpiar Búsqueda"
                            >
                                <Icons.X />
                            </button>
                        )}
                        <button 
                            onClick={openSearch} 
                            className="bg-yellow-400 text-black p-4 rounded-full shadow-xl hover:bg-yellow-500 transition-transform active:scale-95"
                            title="Buscar en Mapa"
                        >
                            <Icons.Search />
                        </button>
                    </div>

                    {/* MODAL DE BÚSQUEDA FLOTANTE */}
                    {isSearchModalOpen && (
                        <div className="absolute inset-0 bg-black/50 z-50 flex items-start pt-12 justify-center p-4 animate-fade-in backdrop-blur-sm">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm animate-scale-up border-t-4 border-red-600">
                                <div className="bg-white p-4 flex justify-between items-center text-slate-800 border-b border-gray-100">
                                    <h3 className="font-bold text-lg flex items-center gap-2">
                                        Buscar Producto
                                    </h3>
                                    <button onClick={() => { setIsSearchModalOpen(false); }} className="hover:bg-gray-100 p-1 rounded text-gray-500"><Icons.X /></button>
                                </div>
                                <div className="p-6">
                                    <div className="space-y-4">
                                        <p className="text-sm text-slate-500 mb-2">
                                            Busca entre los productos registrados en el historial.
                                        </p>
                                        <div className="flex gap-2">
                                            <div className="flex-1 relative">
                                                <AutocompleteInput 
                                                    items={uniqueProducts} 
                                                    value={mapSearchQuery} 
                                                    onChange={setMapSearchQuery} 
                                                    onSelect={handleSearchSubmit} 
                                                    placeholder="Ej: Maíz Blanco..." 
                                                />
                                            </div>
                                            <button onClick={() => handleSearchSubmit(mapSearchQuery)} className="bg-black text-white px-4 py-2 rounded-lg font-bold hover:bg-neutral-800">Ir</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <Modal isOpen={isAddZoneModalOpen} onClose={() => { setIsAddZoneModalOpen(false); cancelPolygon(); }} title={polygonPoints.length >= 3 ? "Configurar Polígono" : "Configurar Botón"} align="top">
                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-slate-500 mb-1">Nombre de la Zona</label>
                                <AutocompleteInput items={locationsList} value={newZoneName} onChange={setNewZoneName} placeholder="Ej: A-1, CHIQUILLADAS, MUESTRARIO" showFullNames={true} />
                                <p className="text-xs text-slate-400 mt-1">Nota: Si el nombre es "CHIQUILLADAS" o "MUESTRARIO", funcionará como enlace a otra página</p>
                            </div>
                            {polygonPoints.length < 3 ? (
                                <div className="flex gap-4">
                                    <div className="flex-1"><label className="block text-xs font-bold text-slate-500 mb-1">Ancho</label><input type="number" className="w-full p-2 border rounded" value={newZoneW} onChange={(e) => setNewZoneW(e.target.value)} /></div>
                                    <div className="flex-1"><label className="block text-xs font-bold text-slate-500 mb-1">Alto</label><input type="number" className="w-full p-2 border rounded" value={newZoneH} onChange={(e) => setNewZoneH(e.target.value)} /></div>
                                </div>
                            ) : (
                                <div className="bg-blue-50 p-3 rounded">
                                    <p className="text-xs text-slate-600">Polígono con {polygonPoints.length} puntos</p>
                                </div>
                            )}
                            <button onClick={confirmAddZone} className="w-full bg-red-600 text-white font-bold py-3 rounded-lg mt-2">Crear</button>
                        </div>
                    </Modal>
                    <Modal isOpen={isCopyModalOpen} onClose={() => setIsCopyModalOpen(false)} title="Guardar Cambios">
                        <div className="space-y-2"><p className="text-xs text-slate-500">Copia esto y pégalo en <code>INITIAL_ZONES</code>:</p><textarea className="w-full h-40 p-2 text-xs font-mono border rounded bg-slate-50" readOnly value={zonesJson} onClick={(e) => e.target.select()} /><button onClick={() => setIsCopyModalOpen(false)} className="w-full bg-slate-700 text-white py-2 rounded text-sm">Cerrar</button></div>
                    </Modal>
                </div>
            );
        };

        const LoginScreen = ({ onLogin }) => {
            const [mode, setMode] = React.useState('login'); // 'login' or 'register'
            const [username, setUsername] = React.useState('');
            const [password, setPassword] = React.useState('');
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState('');

            const handleAuth = async () => {
                if (!username.trim() || !password.trim()) {
                    setError('Por favor completa todos los campos.');
                    return;
                }
                setLoading(true);
                setError('');
                
                try {
                    const response = await fetch(APPS_SCRIPT_URL, {
                        method: 'POST',
                        credentials: 'omit',
                        body: JSON.stringify({
                            action: mode,
                            username: username,
                            password: password
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        if (mode === 'login') {
                            onLogin(data.user || username); // Login exitoso
                        } else {
                            // Registro exitoso, volver al login
                            setMode('login');
                            setError('');
                            alert('Usuario creado exitosamente. Ahora puedes iniciar sesión.');
                        }
                    } else {
                        setError(data.message || 'Error desconocido.');
                    }
                } catch (err) {
                    setError('Error de conexión. Intenta de nuevo.');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            };

            const switchMode = () => {
                setMode(mode === 'login' ? 'register' : 'login');
                setError('');
                setUsername('');
                setPassword('');
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-neutral-100 p-4">
                    <div className="bg-white rounded-xl shadow-2xl p-8 w-full max-w-sm animate-scale-up border-t-4 border-red-600">
                        <div className="flex justify-center mb-6">
                            <div className="bg-red-50 p-4 rounded-full text-red-600">
                                {mode === 'login' ? <Icons.User width="48" height="48" /> : <Icons.Plus width="48" height="48" />}
                            </div>
                        </div>
                        
                        <h2 className="text-2xl font-bold text-center text-slate-800 mb-2">
                            {mode === 'login' ? 'Iniciar Sesión' : 'Crear Usuario'}
                        </h2>
                        <p className="text-center text-slate-500 text-sm mb-6">
                            {mode === 'login' ? 'Ingresa tus credenciales para continuar.' : 'Registra un nuevo usuario para el sistema.'}
                        </p>

                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-slate-500 mb-1 uppercase">Usuario</label>
                                <input 
                                    type="text" 
                                    className="w-full p-3 border border-slate-300 rounded-lg bg-white focus:ring-2 focus:ring-yellow-400 outline-none transition-all"
                                    placeholder="Ej: Juan Perez"
                                    value={username}
                                    onChange={(e) => setUsername(e.target.value)}
                                />
                            </div>
                            <div>
                                <label className="block text-xs font-bold text-slate-500 mb-1 uppercase">Contraseña</label>
                                <input 
                                    type="password" 
                                    className="w-full p-3 border border-slate-300 rounded-lg bg-white focus:ring-2 focus:ring-yellow-400 outline-none transition-all"
                                    placeholder="••••••••"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                />
                            </div>

                            {error && (
                                <div className="bg-red-50 text-red-600 p-3 rounded-lg text-sm flex items-center gap-2 animate-pulse">
                                    <Icons.AlertCircle width="16" height="16" /> {error}
                                </div>
                            )}

                            <button 
                                onClick={handleAuth} 
                                disabled={loading}
                                className={`w-full py-3 rounded-lg font-bold text-white shadow-lg transition-all active:scale-95 flex justify-center items-center gap-2
                                    ${loading ? 'bg-slate-400 cursor-not-allowed' : mode === 'login' ? 'bg-red-600 hover:bg-red-700' : 'bg-black hover:bg-neutral-800'}`}
                            >
                                {loading ? <Icons.RefreshCw className="animate-spin" /> : (mode === 'login' ? 'ENTRAR' : 'REGISTRAR')}
                            </button>

                            <div className="pt-4 border-t border-slate-100 flex justify-center">
                                <button 
                                    onClick={switchMode}
                                    className="text-sm font-medium text-slate-600 hover:text-black hover:underline"
                                >
                                    {mode === 'login' ? 'Crear Usuario Nuevo' : '← Volver al Inicio de Sesión'}
                                </button>
                            </div>
                        </div>
                    </div>
                    <div className="mt-8 text-slate-400 text-xs font-mono">
                        Sistema de Auditoría v2.0
                    </div>
                </div>
            );
        };

        const InventoryAuditApp = () => {
            const [currentUser, setCurrentUser] = React.useState(null); 
            const [isLogoutConfirmOpen, setIsLogoutConfirmOpen] = React.useState(false); // NEW STATE FOR LOGOUT MODAL
            const [isEditorMode, setIsEditorMode] = React.useState(false); // Modo editor controlado desde el header
            const [currentView, setCurrentView] = React.useState('PLANO'); // Estado para controlar la vista actual (PLANO o PLANOGRAMA)

            // Recuperar sesión al cargar
            React.useEffect(() => {
                const storedUser = localStorage.getItem('audit_user');
                if (storedUser) {
                    setCurrentUser(storedUser);
                }
            }, []);

            // Precargar imágenes del plano y planograma para carga instantánea
            React.useEffect(() => {
                const planoImage = new Image();
                const planogramaImage = new Image();
                
                // Precargar imagen del PLANO
                planoImage.src = "https://i.imgur.com/VRncOKx.jpeg";
                
                // Precargar imagen del PLANOGRAMA
                planogramaImage.src = "https://i.imgur.com/Yuiv4JC.jpeg";
                
                // Las imágenes se guardarán en caché del navegador automáticamente
                // cuando se carguen, permitiendo cambio instantáneo de vista
            }, []);

            const handleLoginSuccess = (user) => {
                setCurrentUser(user);
                localStorage.setItem('audit_user', user);
            };

            const confirmLogout = () => {
                setCurrentUser(null);
                localStorage.removeItem('audit_user');
                setActiveTab('map'); // Reset tab
                setIsLogoutConfirmOpen(false);
            };

            const [activeTab, setActiveTab] = React.useState('map');
            const [products, setProducts] = React.useState([]);
            const [locations, setLocations] = React.useState([]);
            const [auditLog, setAuditLog] = React.useState([]);
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState('');
            const [lastUpdate, setLastUpdate] = React.useState(null);
            const [isOnline, setIsOnline] = React.useState(false);
            
            const [isModalOpen, setIsModalOpen] = React.useState(false);
            const [selectedLocation, setSelectedLocation] = React.useState('');
            const [selectedProduct, setSelectedProduct] = React.useState('');
            const [quantity, setQuantity] = React.useState('');
            const [isSaving, setIsSaving] = React.useState(false);
            const [searchTerm, setSearchTerm] = React.useState('');
            const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
            
            // Estados para modal de escaneo
            const [isScannerModalOpen, setIsScannerModalOpen] = React.useState(false);
            const [scannedLocation, setScannedLocation] = React.useState('');
            const [scannedProduct, setScannedProduct] = React.useState('');
            const [scannedQuantity, setScannedQuantity] = React.useState('');
            const [isSearchingCode, setIsSearchingCode] = React.useState(false);
            const [isSelectingLocationFromMap, setIsSelectingLocationFromMap] = React.useState(false);
            
            const quantityInputRef = React.useRef(null);
            const productInputRef = React.useRef(null);
            
            // --- MODO DEBUG Y HERRAMIENTAS ---
            const [showTools, setShowTools] = React.useState(false);
            const [isDebugMode, setIsDebugMode] = React.useState(false);
            const [logs, setLogs] = React.useState([]);
            
            // --- COLA DE GUARDADO Y FOCO ---
            const [saveQueue, setSaveQueue] = React.useState([]); // Cola de objetos payload
            const [focusTarget, setFocusTarget] = React.useState(null); // {location: 'A-1', timestamp: 123}
            const [pendingVerification, setPendingVerification] = React.useState([]);
            const [deletingLocations, setDeletingLocations] = React.useState([]); // Zonas en proceso de borrado

            const addLog = (msg) => setLogs(prev => [...prev, `${new Date().toLocaleTimeString().split(' ')[0]} - ${msg}`]);

            const fetchSheetData = async (silent = false) => {
                if (!APPS_SCRIPT_URL) return;
                if (!silent) setLoading(true);
                try {
                    // Enviar timestamp de última sincronización para optimizar
                    const url = lastSyncTimestamp > 0 
                        ? `${APPS_SCRIPT_URL}?lastSync=${lastSyncTimestamp}`
                        : APPS_SCRIPT_URL;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        credentials: 'omit',
                        headers: {
                            'Content-Type': 'text/plain;charset=utf-8',
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const text = await response.text(); // Get raw text first
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        // console.error("Error parseando JSON:", text); // Log raw response if parse fails
                        throw new Error("Respuesta no válida (HTML en vez de JSON)");
                    }

                    if (data.status === 'success') {
                        // Solo actualizar si hay cambios nuevos (comparar timestamps)
                        const serverTimestamp = data.timestamp || Date.now();
                        const hasChanges = serverTimestamp > lastSyncTimestamp;
                        
                        if (hasChanges || lastSyncTimestamp === 0) {
                            setProducts((data.products || []).filter(p => p && String(p).trim() !== ""));
                            setLocations((data.locations || []).filter(l => l && String(l).trim() !== ""));
                            const newLog = (data.auditLog || []).reverse();
                            setAuditLog(newLog);
                            setPendingVerification(prev => prev.filter(loc => !newLog.some(entry => entry.location === loc)));
                            setDeletingLocations(prev => prev.filter(loc => newLog.some(entry => entry.location === loc)));
                            setLastSyncTimestamp(serverTimestamp);
                            setConsecutiveNoChanges(0); // Resetear contador de sin cambios
                            
                            // Ajustar polling: si hay cambios, volver a intervalo corto
                            setPollingInterval(2000);
                        } else {
                            // No hay cambios: aumentar intervalo gradualmente
                            setConsecutiveNoChanges(prev => prev + 1);
                            if (consecutiveNoChanges > 5) {
                                setPollingInterval(prev => Math.min(prev * 1.2, 10000)); // Máximo 10 segundos
                            }
                        }
                        
                        setLastUpdate(new Date());
                        setIsOnline(true);
                        setError('');
                    } else {
                        setIsOnline(false);
                        setError('Error en status del servidor');
                    }
                } catch (err) { 
                    setIsOnline(false);
                    setError(err.message);
                    setConsecutiveNoChanges(prev => prev + 1);
                } finally { 
                    if (!silent) setLoading(false); 
                }
            };
            
            // Map Name -> Full String for efficient lookup
            const nameToFullProductMap = React.useMemo(() => {
                const map = new Map();
                products.forEach(p => {
                    const name = cleanProductName(p); // Use clean name for mapping
                    // If duplicate names exist, last one wins (or handle logic here if strict code mapping needed)
                    if (name) map.set(name, p);
                });
                return map;
            }, [products]);

            // List of just names for Autocomplete
            const productNamesList = React.useMemo(() => {
                // Pass full strings to autocomplete, it handles cleaning now
                return products;
            }, [products]);

            // Estados para mejoras multi-usuario
            const [consecutiveErrors, setConsecutiveErrors] = React.useState(0);
            const [maxParallel, setMaxParallel] = React.useState(3);

            // Función de guardado con reintentos (exponential backoff)
            const processItemWithRetry = async (itemToSave, maxRetries = 3) => {
                let retryCount = 0;
                let delay = 500; // Empezar con 500ms
                
                while (retryCount < maxRetries) {
                    try {
                        const response = await fetch(APPS_SCRIPT_URL, { 
                            method: 'POST', 
                            body: JSON.stringify(itemToSave),
                            credentials: 'omit'
                        });
                        
                        if (response.ok) {
                            const data = await response.json().catch(() => ({}));
                            setConsecutiveErrors(0); // Resetear errores consecutivos
                            addLog(`✅ ${itemToSave.location} guardado.`);
                            return { success: true, item: itemToSave };
                        } else {
                            throw new Error(`HTTP ${response.status}`);
                        }
                    } catch (err) {
                        retryCount++;
                        
                        if (retryCount >= maxRetries) {
                            // Guardar en localStorage como "pendiente" para reintentar después
                            try {
                                const pendingItems = JSON.parse(localStorage.getItem('pending_saves') || '[]');
                                pendingItems.push({
                                    ...itemToSave,
                                    attempts: retryCount,
                                    lastAttempt: Date.now()
                                });
                                localStorage.setItem('pending_saves', JSON.stringify(pendingItems));
                                addLog(`⚠️ ${itemToSave.location} guardado localmente (se reintentará)`);
                            } catch (e) {
                                addLog(`❌ Error guardando localmente: ${itemToSave.location}`);
                            }
                            
                            setConsecutiveErrors(prev => prev + 1);
                            return { success: false, item: itemToSave, error: err.message };
                        }
                        
                        // Esperar antes de reintentar (exponential backoff)
                        delay = delay * 2; // 500ms, 1000ms, 2000ms
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            };

            // PROCESADOR DE COLA DE GUARDADO OPTIMIZADO CON REINTENTOS
            // Procesa múltiples items en paralelo (hasta maxParallel simultáneos)
            React.useEffect(() => {
                const processQueue = async () => {
                    if (saveQueue.length === 0) return;

                    // Ajustar paralelismo según errores consecutivos
                    const currentMaxParallel = consecutiveErrors > 3 ? 1 : maxParallel;
                    const itemsToProcess = saveQueue.slice(0, currentMaxParallel);
                    
                    try {
                        // Procesar todos los items en paralelo con reintentos
                        const promises = itemsToProcess.map(itemToSave => processItemWithRetry(itemToSave));

                        // Esperar a que todos terminen
                        const results = await Promise.allSettled(promises);
                        
                        // Contar éxitos y fallos
                        const successCount = results.filter(r => r.status === 'fulfilled' && r.value.success).length;
                        const failCount = results.length - successCount;
                        
                        if (failCount > 0) {
                            setConsecutiveErrors(prev => prev + failCount);
                        }
                        
                        // Quitar los items procesados de la cola (todos, exitosos o no, para no atascar)
                        setSaveQueue(prev => prev.slice(itemsToProcess.length));
                        
                        // Actualizar datos inmediatamente después de guardar (sin esperar polling)
                        // Pequeño delay para dar tiempo al servidor de procesar
                        setTimeout(() => {
                            fetchSheetData(true); // Actualización silenciosa
                        }, 500);
                        
                    } catch (err) {
                        addLog(`Error en procesamiento de cola`);
                        setConsecutiveErrors(prev => prev + 1);
                        // En caso de error general, quitar solo el primer item
                        setSaveQueue(prev => prev.slice(1));
                    }
                };
                
                // Ejecutar procesador si hay items
                if (saveQueue.length > 0) {
                    processQueue();
                }
            }, [saveQueue, consecutiveErrors, maxParallel]);

            // Procesar items pendientes de localStorage al reconectar
            React.useEffect(() => {
                const processPendingItems = async () => {
                    try {
                        const pendingItems = JSON.parse(localStorage.getItem('pending_saves') || '[]');
                        
                        if (pendingItems.length > 0) {
                            // Intentar enviar items pendientes (máximo 5 a la vez)
                            const itemsToRetry = pendingItems.slice(0, 5);
                            
                            for (const item of itemsToRetry) {
                                const result = await processItemWithRetry(item, 2); // Solo 2 reintentos para pendientes
                                
                                if (result.success) {
                                    // Remover del localStorage
                                    const updated = pendingItems.filter(p => p.id !== item.id && p.timestamp !== item.timestamp);
                                    localStorage.setItem('pending_saves', JSON.stringify(updated));
                                    addLog(`✅ Item pendiente guardado: ${item.location}`);
                                }
                            }
                        }
                    } catch (e) {
                        // Silenciar errores de procesamiento de pendientes
                    }
                };
                
                // Procesar pendientes cada 30 segundos
                const interval = setInterval(processPendingItems, 30000);
                processPendingItems(); // Ejecutar inmediatamente al cargar
                
                return () => clearInterval(interval);
            }, []);

            // Efecto para Ctrl+D (RESTAURADO Y PROTEGIDO PARA ADMIN)
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey && e.key === 'd') {
                        e.preventDefault();
                        // Verificar si hay usuario logueado y si es ADMIN
                        if (currentUser && currentUser.toUpperCase() === 'ADMIN') {
                            setShowTools(prev => !prev);
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentUser]); // Dependencia necesaria para leer el usuario actualizado

            // Polling adaptativo: ajusta intervalo según actividad y cambios
            const [pollingInterval, setPollingInterval] = React.useState(2000);
            const [consecutiveNoChanges, setConsecutiveNoChanges] = React.useState(0);
            const [lastSyncTimestamp, setLastSyncTimestamp] = React.useState(0);
            const [isUserActive, setIsUserActive] = React.useState(true);

            // Detectar si el usuario está activo (no en background)
            React.useEffect(() => {
                const handleVisibilityChange = () => {
                    setIsUserActive(!document.hidden);
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
            }, []);

            // Polling adaptativo optimizado
            React.useEffect(() => { 
                fetchSheetData(); 
                
                const interval = setInterval(() => {
                    // Solo hacer polling si:
                    // 1. No hay items en cola
                    // 2. El usuario está activo (no en background)
                    if (saveQueue.length === 0 && isUserActive) {
                        fetchSheetData(true);
                    }
                }, pollingInterval);
                
                return () => clearInterval(interval);
            }, [saveQueue.length, pollingInterval, isUserActive]);
            
            // Effect to focus on Product input when modal opens
            React.useEffect(() => {
                if (isModalOpen && productInputRef.current) {
                    setTimeout(() => {
                        productInputRef.current.focus();
                        productInputRef.current.select();
                    }, 50);
                }
            }, [isModalOpen]);


            // Función de formateo de fecha segura (ACTUALIZADA + DEBUG)
            const formatDate = (val) => {
                if (!val) return '-';
                
                // Si el valor es texto y ya parece una fecha (tiene / o : y no es formato ISO 'T'),
                // lo devolvemos TAL CUAL viene de la base de datos.
                if (typeof val === 'string' && (val.includes('/') || val.includes(':')) && !val.includes('T')) {
                    return val;
                }

                let dateObj = null;

                // Caso 1: String con formato DD/MM/YYYY o DD-MM-YYYY (o ISO con T)
                if (typeof val === 'string') {
                    const cleanVal = val.replace(/['"]/g, '');
                    if (cleanVal.includes('T') || cleanVal.match(/^\d{4}-\d{2}-\d{2}/)) {
                        dateObj = new Date(cleanVal);
                    } else if (cleanVal.includes('/')) {
                        const parts = cleanVal.split(/[\/\s:]/); // Separar por / espacio :
                        if (parts.length >= 3) {
                            const day = parseInt(parts[0], 10);
                            const month = parseInt(parts[1], 10) - 1; // Mes 0-11
                            let year = parseInt(parts[2], 10);
                            if (year < 100) year += 2000; // Asumir 20xx
                            
                            let hours = 0, minutes = 0, seconds = 0;
                            if (parts.length >= 5) {
                                hours = parseInt(parts[3], 10);
                                minutes = parseInt(parts[4], 10);
                                if (parts[5]) seconds = parseInt(parts[5], 10);
                            }
                            dateObj = new Date(year, month, day, hours, minutes, seconds);
                        }
                    } else {
                        // Si es texto pero no parece fecha standard, lo retornamos tal cual (ej: "Ayer")
                        return val;
                    }
                }
                
                // Caso 2: Timestamp numérico (ID o timestamp real)
                if (!dateObj && !isNaN(Number(val))) {
                    const num = Number(val);
                    // Solo tratamos como fecha si el número es GRANDE (un timestamp real en milisegundos)
                    // 1000000000000 equivale al año 2001. Si es menor (ej. id: 55), NO es una fecha.
                    if (num > 1000000000000) {
                        dateObj = new Date(num);
                    } else {
                        return "-"; 
                    }
                }
                
                // Fallback final: Si es texto y Date() lo entiende
                if (!dateObj && typeof val === 'string') {
                    const tryDate = new Date(val);
                    if (!isNaN(tryDate.getTime())) {
                        dateObj = tryDate;
                    }
                }
                
                // Si después de todo no es fecha válida, devolvemos el valor original (o un guion)
                if (!dateObj || isNaN(dateObj.getTime())) return val;

                // Formatear a dd/mm/yyyy hh:mm:ss
                const day = String(dateObj.getDate()).padStart(2, '0');
                const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                const year = String(dateObj.getFullYear()); 
                const hours = String(dateObj.getHours()).padStart(2, '0');
                const minutes = String(dateObj.getMinutes()).padStart(2, '0');
                const seconds = String(dateObj.getSeconds()).padStart(2, '0');

                return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
            }

            // Helper to get formatted date for folder name (ddMMMyy)
            const getFormattedDateForFolder = () => {
                const date = new Date();
                const day = String(date.getDate()).padStart(2, '0');
                const months = ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'];
                const month = months[date.getMonth()];
                const year = String(date.getFullYear()).slice(-2);
                return `${day}${month}${year}`;
            };

            // Función para generar Reportes (PDF + CSV en ZIP)
            const generateReports = () => {
                const { jsPDF } = window.jspdf;
                const zip = new JSZip();
                const dateStr = getFormattedDateForFolder();
                const folderName = `AuditoriaPisodeventas${dateStr}`;
                const folder = zip.folder(folderName);
                
                // 0. Build a lookup map for codes from the products catalog
                // keys: Clean Name (lowercase for safety), value: Code
                const productCodeMap = new Map();
                products.forEach(fullStr => {
                    const c = getProductCode(fullStr);
                    const n = getProductName(fullStr);
                    if (c && n) {
                        productCodeMap.set(n.toLowerCase(), c);
                    }
                });
                
                // 1. Generar PDF
                const doc = new jsPDF();
                doc.setFontSize(18);
                doc.text("Reporte de Auditoría", 14, 22);
                doc.setFontSize(11);
                doc.setTextColor(100);
                doc.text(`Fecha: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, 14, 30);
                
                const tableColumn = ["Lugar", "Codigo", "Producto", "Cantidad", "Fecha Registro", "Usuario"];
                const tableRows = [];
                const csvRows = [["Lugar", "Codigo", "Producto", "Cantidad", "Fecha Registro", "Usuario"]]; // Header CSV

                const chronologicalLog = [...auditLog].sort((a, b) => {
                    const timeA = a.timestamp || a.id;
                    const timeB = b.timestamp || b.id;
                    return new Date(timeA) - new Date(timeB);
                });

                chronologicalLog.forEach(ticket => {
                    if (!ticket.location || !ticket.product || !ticket.quantity) return;

                    const findDateValue = (obj) => {
                        const candidates = ['FECHA REGISTRO', 'fecha registro', 'Fecha Registro', 'FECHAREGISTRO', 'fechaRegistro', 'timestamp', 'date', 'Date', 'fecha', 'Fecha'];
                        for (const key of candidates) {
                            if (obj[key]) return obj[key];
                        }
                        return obj.id || obj.timestamp;
                    };

                    const rawDate = findDateValue(ticket);
                    const dateStr = formatDate(rawDate);
                    
                    // Separar Código y Producto
                    // Si el producto en ticket no tiene codigo, buscar en el mapa
                    let fullProd = ticket.product;
                    let { code, name } = extractCodeAndName(fullProd);
                    
                    if (!code) {
                         // Intentar recuperar codigo usando el nombre limpio
                         const cleanName = cleanProductName(fullProd);
                         const foundCode = productCodeMap.get(cleanName.toLowerCase());
                         if (foundCode) {
                             code = foundCode;
                             name = cleanName; // Usar nombre limpio
                         }
                    }

                    const userStr = ticket.user || ticket.usuario || '-';

                    const rowData = [
                        ticket.location,
                        code,
                        name,
                        ticket.quantity,
                        dateStr,
                        userStr
                    ];

                    tableRows.push(rowData);
                    // CSV Row logic (basic escaping)
                    const csvRow = rowData.map(val => `"${String(val).replace(/"/g, '""')}"`);
                    csvRows.push(csvRow);
                });

                doc.autoTable({
                    head: [tableColumn],
                    body: tableRows,
                    startY: 40,
                    theme: 'grid',
                    styles: { fontSize: 10 },
                    headStyles: { fillColor: [220, 38, 38] } 
                });
                
                const pdfBlob = doc.output('blob');

                // 2. Generar CSV
                const csvContent = csvRows.map(e => e.join(",")).join("\n");
                const csvBlob = new Blob([csvContent], { type: "text/csv;charset=utf-8" });

                // 3. Agregar al ZIP
                folder.file(`${folderName}.pdf`, pdfBlob);
                folder.file(`${folderName}.csv`, csvBlob);

                // 4. Descargar ZIP
                zip.generateAsync({type:"blob"}).then(function(content) {
                    window.saveAs(content, `${folderName}.zip`);
                });
            };


            // Función para buscar código en la base de datos
            const searchCodeInDatabase = async (code) => {
                setIsSearchingCode(true);
                try {
                    // Limpiar el código: quitar espacios y normalizar
                    const cleanCode = String(code || '').trim();
                    console.log('🔍 Buscando código:', cleanCode);
                    
                    // Usar el mismo método que funciona para otras acciones (sin headers para evitar CORS)
                    const payload = {
                        action: 'searchCode',
                        code: cleanCode
                    };
                    
                    const response = await fetch(APPS_SCRIPT_URL, {
                        method: 'POST',
                        credentials: 'omit',
                        body: JSON.stringify(payload)
                    });
                    
                    const data = await response.json();
                    console.log('📥 Respuesta del servidor:', data);
                    
                    if (data.status === 'success') {
                        // Abrir modal con los datos encontrados
                        // Orden: Producto (no editable), Ubicación (editable si existe), Cantidad (editable)
                        setScannedProduct(data.producto || '');
                        setScannedLocation(data.ubicacion || ''); // Puede estar vacío si no tiene ubicación
                        setScannedQuantity('');
                        setIsScannerModalOpen(true);
                    } else {
                        // Mostrar mensaje más detallado si hay información de debug
                        let mensaje = 'Código no encontrado en la base de datos';
                        if (data.debug) {
                            console.log('🐛 Debug info:', data.debug);
                            mensaje += `\n\nCódigo buscado: "${data.debug.codigoBuscado}"\nTotal de códigos en BD: ${data.debug.totalCodigos}`;
                            if (data.debug.primerosCodigos && data.debug.primerosCodigos.length > 0) {
                                mensaje += `\nPrimeros códigos en BD:\n${data.debug.primerosCodigos.join('\n')}`;
                            }
                        }
                        alert(mensaje);
                    }
                } catch (error) {
                    console.error('❌ Error buscando código:', error);
                    alert('Error al buscar el código en la base de datos: ' + error.message);
                } finally {
                    setIsSearchingCode(false);
                }
            };

            // Handler cuando se escanea un código
            const handleCodeScanned = (code) => {
                searchCodeInDatabase(code);
            };

            // Guardar datos del escáner
            const handleSaveScanned = () => {
                if (!scannedLocation || !scannedProduct || !scannedQuantity) {
                    return alert("Faltan datos");
                }
                
                // Reconstruir producto completo si es necesario
                let productToSave = scannedProduct;
                if (nameToFullProductMap.has(scannedProduct)) {
                    productToSave = nameToFullProductMap.get(scannedProduct);
                }
                
                const timestamp = Date.now();
                const payload = {
                    id: timestamp,
                    location: scannedLocation,
                    product: productToSave,
                    quantity: scannedQuantity,
                    timestamp: timestamp,
                    user: currentUser
                };
                
                // Agregar a la cola de guardado
                setSaveQueue(prev => [...prev, payload]);
                setPendingVerification(prev => [...prev, scannedLocation]);
                
                // Cerrar modal
                setIsScannerModalOpen(false);
                setScannedLocation('');
                setScannedProduct('');
                setScannedQuantity('');
                
                addLog(`Guardado desde escáner: ${scannedLocation}`);
            };

            const handleLocationClick = (locName) => {
                // Si estamos en modo selección desde mapa (para el escáner), copiar el nombre y cerrar el modo
                if (isSelectingLocationFromMap) {
                    setScannedLocation(locName);
                    setIsSelectingLocationFromMap(false);
                    setActiveTab('scanner'); // Volver a la pestaña del escáner
                    setIsScannerModalOpen(true); // Reabrir el modal con los datos
                    return;
                }
                
                addLog(`Abriendo: ${locName}`);
                setSelectedLocation(locName);
                const existingEntry = auditLog.find(entry => entry.location === locName);
                if (existingEntry) {
                    // Use the existing entry full product string
                    setSelectedProduct(existingEntry.product); 
                    setQuantity(existingEntry.quantity);
                } else {
                    setSelectedProduct('');
                    setQuantity('');
                }
                setIsModalOpen(true);
            };

            const handleSaveAudit = () => {
                if (!selectedLocation || !selectedProduct || !quantity) return alert("Faltan datos");
                
                // DETECCIÓN DE CONFLICTOS: Verificar si alguien más editó esta ubicación recientemente
                const existingEntry = auditLog.find(entry => entry.location === selectedLocation);
                
                if (existingEntry) {
                    const entryTimestamp = existingEntry.timestamp || existingEntry.id || 0;
                    const timeSinceLastEdit = Date.now() - entryTimestamp;
                    
                    // Si fue editado hace menos de 5 segundos por otro usuario, mostrar advertencia
                    if (timeSinceLastEdit < 5000 && existingEntry.user && existingEntry.user !== currentUser) {
                        const secondsAgo = Math.round(timeSinceLastEdit / 1000);
                        const confirmMessage = `⚠️ Esta ubicación fue editada hace ${secondsAgo} segundo${secondsAgo !== 1 ? 's' : ''} por ${existingEntry.user}.\n\n¿Deseas sobrescribir su cambio?`;
                        
                        if (!window.confirm(confirmMessage)) {
                            addLog(`Guardado cancelado: ${selectedLocation} (conflicto detectado)`);
                            return; // Cancelar guardado
                        }
                    }
                }
                
                // Reconstruir producto completo si el usuario escribió solo el nombre y existe en el mapa
                let productToSave = selectedProduct;
                
                if (nameToFullProductMap.has(selectedProduct)) {
                     productToSave = nameToFullProductMap.get(selectedProduct);
                }

                // OPTIMISTIC UPDATE: Actualizar UI Inmediatamente
                const timestamp = Date.now();
                
                const payload = { 
                    id: timestamp, 
                    location: selectedLocation, 
                    product: productToSave, // Guardar FULL STRING
                    quantity: quantity, 
                    timestamp: timestamp, 
                    user: currentUser 
                };
                
                // Agregar a la cola de guardado
                setSaveQueue(prev => [...prev, payload]);
                setPendingVerification(prev => [...prev, selectedLocation]);
                
                // Cerrar modal inmediatamente
                setIsModalOpen(false);
                setQuantity(''); setSelectedProduct('');
                
                addLog(`Guardado en cola: ${selectedLocation}`);
            };
            
            const handleQuantityKeyDown = (e) => {
                // Prevenir letras
                if (['e', 'E', '+', '-'].includes(e.key)) {
                    e.preventDefault();
                    return;
                }

                if (e.key === 'Enter') {
                    handleSaveAudit();
                }
            };

            const confirmDelete = async () => {
                // Agregar a cola de guardado como acción de borrado
                const payload = { location: selectedLocation, action: 'delete' };
                setSaveQueue(prev => [...prev, payload]);
                
                // Marcar como "borrando" visualmente (Rojo)
                setDeletingLocations(prev => [...prev, selectedLocation]);
                
                // Cerrar modal inmediatamente
                setIsDeleteConfirmOpen(false);
                setIsModalOpen(false);
                setQuantity(''); setSelectedProduct('');
                
                addLog(`Borrando en cola: ${selectedLocation}`);
            };
            
            // Función para ir al plano
            const goToMapAndFocus = (location) => {
                // Verificar si la ubicación pertenece a CHIQUILLADAS (PLANOGRAMA)
                // Buscar en INITIAL_ZONES_PLANOGRAMA si existe una zona con ese nombre
                const isChiquilladasLocation = INITIAL_ZONES_PLANOGRAMA.some(zone => zone.name === location);
                
                if (isChiquilladasLocation && currentView !== 'PLANOGRAMA') {
                    // Si la ubicación es de CHIQUILLADAS y no estamos en PLANOGRAMA, cambiar a esa vista
                    setCurrentView('PLANOGRAMA');
                } else if (!isChiquilladasLocation && currentView === 'PLANOGRAMA') {
                    // Si la ubicación NO es de CHIQUILLADAS pero estamos en PLANOGRAMA, volver a PLANO
                    setCurrentView('PLANO');
                }
                
                setActiveTab('map');
                setFocusTarget({ location, timestamp: Date.now() });
            };

            // Filtrado y Ordenamiento para Lista: Antiguo -> Nuevo (CORREGIDO AQUI)
            const auditMap = React.useMemo(() => {
                const map = new Map();
                auditLog.forEach(a => map.set(a.location, a));
                return map;
            }, [auditLog]);

            // Mapeo de nombres cortados a nombres completos desde las zonas
            // Esto asegura que en la lista de lugares se muestre el nombre completo
            // SOLO para la lista de lugares, NO para productos
            const locationNameMap = React.useMemo(() => {
                const map = new Map();
                // Agregar todas las zonas de PLANO
                INITIAL_ZONES.forEach(zone => {
                    if (zone.name) {
                        // Mapear el nombre completo a sí mismo
                        map.set(zone.name, zone.name);
                        // Si el nombre tiene guion, crear mapeo de la parte antes del guion al nombre completo
                        if (zone.name.includes('-')) {
                            const shortName = zone.name.split('-')[0].trim();
                            // Solo mapear si no existe ya otro mapeo para ese nombre corto
                            if (!map.has(shortName) || map.get(shortName) === shortName) {
                                map.set(shortName, zone.name);
                            }
                        }
                    }
                });
                // Agregar todas las zonas de PLANOGRAMA
                INITIAL_ZONES_PLANOGRAMA.forEach(zone => {
                    if (zone.name) {
                        // Mapear el nombre completo a sí mismo
                        map.set(zone.name, zone.name);
                        // Si el nombre tiene guion, crear mapeo de la parte antes del guion al nombre completo
                        if (zone.name.includes('-')) {
                            const shortName = zone.name.split('-')[0].trim();
                            // Solo mapear si no existe ya otro mapeo para ese nombre corto
                            if (!map.has(shortName) || map.get(shortName) === shortName) {
                                map.set(shortName, zone.name);
                            }
                        }
                    }
                });
                return map;
            }, []);

            // Función para obtener el nombre completo de una ubicación
            // SOLO para mostrar en la lista de lugares, NO afecta productos
            const getFullLocationName = (loc) => {
                // Asegurar que loc sea un string
                if (!loc) return String(loc || '');
                const locStr = String(loc);
                
                // Primero intentar buscar coincidencia exacta
                if (locationNameMap.has(locStr)) {
                    return locationNameMap.get(locStr);
                }
                // Si el nombre tiene guion, intentar buscar la parte antes del guion
                if (locStr.includes('-')) {
                    const shortName = locStr.split('-')[0].trim();
                    if (locationNameMap.has(shortName)) {
                        return locationNameMap.get(shortName);
                    }
                }
                // Buscar en todas las zonas si alguna tiene un nombre que empiece con el nombre corto
                const allZones = [...INITIAL_ZONES, ...INITIAL_ZONES_PLANOGRAMA];
                for (const zone of allZones) {
                    if (zone.name) {
                        // Si el nombre de la zona empieza con el nombre corto del servidor
                        if (zone.name.startsWith(locStr.trim())) {
                            return zone.name;
                        }
                        // Si el nombre corto del servidor es el inicio del nombre de la zona (antes del guion)
                        const zoneShortName = zone.name.includes('-') ? zone.name.split('-')[0].trim() : zone.name;
                        if (zoneShortName === locStr.trim()) {
                            return zone.name;
                        }
                    }
                }
                // Si no se encuentra, devolver el nombre original como string
                return locStr;
            };

            const sortedFilteredLocations = React.useMemo(() => {
                // 1. Filtrar
                const searchLower = searchTerm.toLowerCase();
                const filtered = locations.filter(loc => {
                    const auditData = auditMap.get(loc);
                    const matchesLoc = String(loc).toLowerCase().includes(searchLower);
                    // Match against NAME only for cleaner search
                    const prodName = auditData ? cleanProductName(auditData.product) : "";
                    const matchesProd = prodName.toLowerCase().includes(searchLower);
                    return matchesLoc || matchesProd;
                });
                
                // 2. Ordenar: Registrados (Nuevo->Antiguo) primero, luego pendientes
                return filtered.sort((a, b) => {
                    const entryA = auditMap.get(a);
                    const entryB = auditMap.get(b);
                    
                    // Ambos tienen datos: ordenar por ID (timestamp) descendente (Nuevo -> Antiguo)
                    if (entryA && entryB) {
                        return entryB.id - entryA.id; 
                    }
                    // Si solo A tiene datos, va antes
                    if (entryA) return -1; 
                    // Si solo B tiene datos, va antes
                    if (entryB) return 1;  
                    // Ambos pendientes: orden alfabético
                    // Asegurar que a y b sean strings antes de usar localeCompare
                    const strA = String(a || '');
                    const strB = String(b || '');
                    return strA.localeCompare(strB); 
                });
            }, [locations, auditMap, searchTerm]);


            const auditedLocNames = auditLog.map(l => l.location);
            const isCurrentLocAudited = auditedLocNames.includes(selectedLocation);
            
            // Productos únicos para búsqueda en mapa
            const uniqueProducts = [...new Set(auditLog.map(item => item.product))].sort();

            // --- DETECCIÓN DE COLUMNAS PARA DIAGNÓSTICO ---
            const detectedColumns = React.useMemo(() => {
                if (auditLog.length > 0) {
                    return Object.keys(auditLog[0]);
                }
                return [];
            }, [auditLog]);

            // --- Lógica de fecha robusta reutilizable ---
            const getEntryDate = (entry) => {
                const candidates = ['FECHA REGISTRO', 'fecha registro', 'Fecha Registro', 'FECHAREGISTRO', 'fechaRegistro', 'timestamp', 'date', 'Date', 'fecha', 'Fecha'];
                for (const key of candidates) {
                    if (entry[key]) return formatDate(entry[key]);
                }
                // Fallback a timestamp/id
                return formatDate(entry.id || entry.timestamp);
            };

            // RENDERIZADO CONDICIONAL DE LOGIN
            if (!currentUser) {
                return <LoginScreen onLogin={handleLoginSuccess} />;
            }
            
            return (
                <div className="flex flex-col h-full bg-neutral-50 text-slate-800 font-sans prevent-browser-zoom">
                    <header className="bg-red-700 text-white p-4 shadow-md z-20 flex justify-between items-center shrink-0">
                        <div className="flex items-center gap-3">
                            <div className={`w-3 h-3 rounded-full ${isOnline ? 'bg-green-400 shadow-[0_0_8px_rgba(74,222,128,0.8)]' : 'bg-red-500 animate-pulse'}`} title={isOnline ? "Conectado" : "Desconectado"}></div>
                            <div className="flex items-center gap-2">
                                <h1 className="text-xl font-bold tracking-tight">Auditoría Inventario</h1>
                                {currentView === 'PLANOGRAMA' && (
                                    <button onClick={() => setCurrentView('PLANO')} className="ml-2 text-xs bg-white/20 hover:bg-white/30 px-2 py-1 rounded flex items-center gap-1">
                                        <Icons.ArrowLeft /> Volver al Plano
                                    </button>
                                )}
                            </div>
                             {/* MOSTRAR ERROR SI EXISTE */}
                             {error && <span className="ml-2 text-xs bg-red-900 px-2 py-1 rounded text-white font-mono hidden sm:inline-block truncate max-w-[150px]" title={error}>{error}</span>}
                        </div>
                        
                        <div className="flex items-center gap-3">
                            {/* Botón Modo Editor - Solo visible para ADMIN */}
                            {currentUser && currentUser.toUpperCase() === 'ADMIN' && (
                                <button
                                    onClick={() => setIsEditorMode(prev => !prev)}
                                    className={`p-2 rounded-lg transition-colors flex items-center gap-2 ${
                                        isEditorMode 
                                            ? 'bg-yellow-500 text-black hover:bg-yellow-600' 
                                            : 'bg-white/20 text-white hover:bg-white/30'
                                    }`}
                                    title={isEditorMode ? "Desactivar Modo Editor" : "Activar Modo Editor"}
                                >
                                    <Icons.Code width="16" height="16" />
                                    <span className="text-xs font-bold">{isEditorMode ? 'Editor ON' : 'Editor'}</span>
                                </button>
                            )}
                            
                            <div 
                                onClick={() => setIsLogoutConfirmOpen(true)} 
                                className="flex items-center gap-2 cursor-pointer hover:bg-red-800/50 p-2 rounded-lg transition-colors"
                                title="Toca para cerrar sesión"
                            >
                                 <div className="text-xs bg-white text-red-700 px-3 py-1 rounded-full flex items-center gap-2 font-bold shadow-sm">
                                    <Icons.User width="14" height="14" /> 
                                    <span>{currentUser}</span>
                                 </div>
                            </div>
                        </div>
                    </header>

                    <main className="flex-1 overflow-hidden relative min-h-0">
                        <div className={`h-full w-full relative ${activeTab === 'map' ? 'block' : 'hidden'}`}>
                            {/* Crear lista de ubicaciones con nombres completos para el editor */}
                            {(() => {
                                // Combinar ubicaciones del servidor con nombres completos de las zonas
                                const allZoneNames = [...INITIAL_ZONES, ...INITIAL_ZONES_PLANOGRAMA].map(z => z.name).filter(Boolean);
                                const locationsWithFullNames = [...new Set([...allZoneNames, ...locations])];
                                return (
                                    <MapEditor 
                                        onLocationClick={handleLocationClick} 
                                        auditedLocations={auditedLocNames} 
                                        locationsList={locationsWithFullNames} 
                                        isDebugMode={isDebugMode} 
                                        addLog={addLog}
                                        auditLog={auditLog}
                                        focusTarget={focusTarget}
                                        pendingLocations={pendingVerification}
                                        deletingLocations={deletingLocations}
                                        currentUser={currentUser}
                                        currentView={currentView}
                                        setCurrentView={setCurrentView}
                                        isEditorMode={isEditorMode}
                                        setIsEditorMode={setIsEditorMode}
                                        isSelectingLocationFromMap={isSelectingLocationFromMap}
                                    />
                                );
                            })()}
                        </div>

                        <div className={`h-full overflow-y-auto p-4 scroll-container touch-pan-y ${activeTab === 'places' ? 'block' : 'hidden'}`}>
                            <div className="relative mb-4 sticky top-0 z-10 flex gap-2">
                                <div className="relative flex-1">
                                    <div className="absolute top-3 left-3 text-slate-400"><Icons.Search /></div>
                                    <input type="text" placeholder="Buscar lugar o producto..." className="w-full pl-10 p-3 rounded-lg border shadow-sm focus:ring-2 focus:ring-red-500 outline-none" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
                                </div>
                                <button onClick={generateReports} className="bg-red-600 text-white p-3 rounded-lg shadow hover:bg-red-700 active:scale-95 transition-transform" title="Descargar Reporte ZIP (PDF + CSV)">
                                    <Icons.FileText />
                                </button>
                            </div>
                            <div className="space-y-2 pb-20">{sortedFilteredLocations.map((loc, idx) => {
                                const data = auditMap.get(loc);
                                // Obtener el nombre completo para mostrar en la lista
                                const fullLocationName = getFullLocationName(loc);
                                return ( 
                                    <div key={idx} onClick={() => handleLocationClick(loc)} className={`p-4 rounded-lg border shadow-sm flex flex-col gap-1 cursor-pointer bg-white hover:bg-gray-50 transition-colors ${data ? 'border-l-4 border-l-green-500' : ''}`}>
                                        <div className="flex justify-between items-center">
                                            {/* NOMBRE + ICONO DE MAPA JUNTOS */}
                                            <div className="flex items-center gap-2">
                                                <span className="font-semibold text-slate-800">{fullLocationName}</span>
                                                <button onClick={(e) => { e.stopPropagation(); goToMapAndFocus(loc); }} className="text-red-500 p-1 hover:bg-red-50 rounded" title="Ver en mapa"><Icons.Target /></button>
                                            </div>
                                            {/* ICONO DE ESTADO A LA DERECHA */}
                                            {data ? <Icons.CheckCircle className="text-green-600 w-5 h-5" /> : <span className="text-xs text-slate-400 bg-slate-100 px-2 py-1 rounded">Pendiente</span>}
                                        </div>
                                        {data && (
                                            <div className="mt-1 border-t border-slate-100 pt-2">
                                                <div className="text-sm text-slate-600 flex justify-between items-center">
                                                    <span className="truncate flex-1 font-medium text-slate-900">{cleanProductName(data.product)}</span>
                                                    <span className="font-bold bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded text-xs">{data.quantity}</span>
                                                </div>
                                                <div className="flex justify-between items-center mt-2">
                                                     <div className="text-[10px] text-slate-500 font-mono flex items-center gap-1 bg-slate-100 px-1.5 py-0.5 rounded">
                                                        <Icons.User width="10" height="10" /> {data.user || '-'}
                                                     </div>
                                                     <div className="text-[10px] text-slate-400 font-mono">
                                                        {getEntryDate(data)}
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}</div>
                        </div>

                        <div className={`h-full overflow-hidden relative ${activeTab === 'scanner' ? 'block' : 'hidden'}`}>
                            <ScannerComponent activeTab={activeTab} onCodeScanned={handleCodeScanned} />
                        </div>
                        
                        {isDebugMode && <DebugConsole logs={logs} />}
                    </main>

                    {/* Indicador de modo selección desde mapa */}
                    {isSelectingLocationFromMap && (
                        <div className="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 bg-yellow-500 text-white px-6 py-3 rounded-lg shadow-xl border-2 border-yellow-600">
                            <div className="flex items-center gap-3">
                                <Icons.Map width="24" height="24" />
                                <div>
                                    <p className="font-bold text-lg">Selecciona una zona del mapa</p>
                                    <p className="text-sm opacity-90">Haz clic en cualquier zona para seleccionarla</p>
                                </div>
                            </div>
                        </div>
                    )}

                    <nav className="bg-white border-t border-slate-200 flex justify-around p-2 pb-safe shadow-lg z-20 shrink-0">
                        <button onClick={() => setActiveTab('map')} className={`flex flex-col items-center p-2 rounded-lg w-20 transition-colors ${activeTab === 'map' ? 'text-red-600' : 'text-slate-400 hover:text-slate-600'}`}><Icons.Map /><span className="text-xs font-medium">{currentView === 'PLANOGRAMA' ? 'PLANOGRAMA' : 'Plano'}</span></button>
                        <button onClick={() => setActiveTab('places')} className={`flex flex-col items-center p-2 rounded-lg w-20 transition-colors ${activeTab === 'places' ? 'text-red-600' : 'text-slate-400 hover:text-slate-600'}`}><Icons.List /><span className="text-xs font-medium">Lista</span></button>
                        <button onClick={() => setActiveTab('scanner')} className={`flex flex-col items-center p-2 rounded-lg w-20 transition-colors ${activeTab === 'scanner' ? 'text-red-600' : 'text-slate-400 hover:text-slate-600'}`}><Icons.Scanner /><span className="text-xs font-medium">Escáner</span></button>
                    </nav>

                    {/* Modal de escaneo - Solo mostrar si no estamos seleccionando desde el mapa */}
                    <Modal isOpen={isScannerModalOpen && !isSelectingLocationFromMap} onClose={() => {
                        setIsScannerModalOpen(false);
                        setIsSelectingLocationFromMap(false);
                    }} title="Auditar desde Escáner" align="top">
                        <div className="space-y-5">
                            {isSearchingCode && (
                                <div className="text-center py-4">
                                    <p className="text-slate-600">Buscando código en la base de datos...</p>
                                </div>
                            )}
                            {!isSearchingCode && (() => {
                                // Crear lista de ubicaciones con nombres completos para el modal
                                const allZoneNames = [...INITIAL_ZONES, ...INITIAL_ZONES_PLANOGRAMA].map(z => z.name).filter(Boolean);
                                const locationsWithFullNames = [...new Set([...allZoneNames, ...locations])];
                                
                                return (
                                    <>
                                        {/* PRIMERA CAJA: PRODUCTO (NO EDITABLE) */}
                                        <div>
                                            <label className="block text-sm font-bold mb-2 text-slate-700">Producto</label>
                                            <input 
                                                type="text" 
                                                className="w-full p-3 border rounded-lg bg-slate-100" 
                                                value={scannedProduct} 
                                                readOnly
                                            />
                                        </div>
                                        
                                        {/* SEGUNDA CAJA: UBICACIÓN (EDITABLE, solo si tiene valor o siempre mostrar para poder agregar) */}
                                        <div>
                                            <label className="block text-sm font-bold mb-2 text-slate-700">Ubicación</label>
                                            <div className="flex gap-2">
                                                <div className="flex-1">
                                                    <AutocompleteInput 
                                                        items={locationsWithFullNames} 
                                                        value={scannedLocation} 
                                                        onChange={setScannedLocation} 
                                                        placeholder={scannedLocation ? "Buscar o editar ubicación..." : "Buscar o agregar ubicación..."} 
                                                        showFullNames={true}
                                                    />
                                                </div>
                                                <button
                                                    onClick={() => {
                                                        setIsSelectingLocationFromMap(true);
                                                        setIsScannerModalOpen(false); // Cerrar el modal temporalmente
                                                        setActiveTab('map');
                                                    }}
                                                    className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 active:scale-95 transition-transform flex items-center justify-center shrink-0"
                                                    title="Seleccionar ubicación desde el mapa"
                                                >
                                                    <Icons.Map width="20" height="20" />
                                                </button>
                                            </div>
                                        </div>
                                        
                                        {/* TERCERA CAJA: CANTIDAD (EDITABLE) */}
                                        <div>
                                            <label className="block text-sm font-bold mb-2 text-slate-700">Cantidad</label>
                                            <input 
                                                type="number" 
                                                className="w-full p-3 border rounded-lg text-center text-2xl focus:ring-2 focus:ring-yellow-400 outline-none" 
                                                value={scannedQuantity} 
                                                onFocus={(e) => e.target.select()}
                                                onChange={(e) => setScannedQuantity(e.target.value)} 
                                                onKeyDown={(e) => {
                                                    if (['e', 'E', '+', '-'].includes(e.key)) {
                                                        e.preventDefault();
                                                    }
                                                    if (e.key === 'Enter') {
                                                        handleSaveScanned();
                                                    }
                                                }}
                                                autoFocus
                                            />
                                        </div>
                                    
                                    <div className="flex gap-2 mt-4">
                                        <button 
                                            onClick={handleSaveScanned} 
                                            className="flex-1 bg-red-600 text-white font-bold py-3 rounded-lg hover:bg-red-700 active:scale-95 transition-transform"
                                        >
                                            Confirmar
                                        </button>
                                        <button 
                                            onClick={() => setIsScannerModalOpen(false)} 
                                            className="px-4 bg-slate-200 text-slate-700 font-bold py-3 rounded-lg hover:bg-slate-300 active:scale-95 transition-transform"
                                        >
                                            Cancelar
                                        </button>
                                    </div>
                                </>
                                );
                            })()}
                        </div>
                    </Modal>

                    <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title={`Auditar: ${selectedLocation}`} align="top">
                        <div className="space-y-5">
                            <div>
                                <label className="block text-sm font-bold mb-2 text-slate-700">Producto</label>
                                <AutocompleteInput 
                                    inputRef={productInputRef}
                                    items={products} 
                                    value={selectedProduct} 
                                    onChange={setSelectedProduct} 
                                    placeholder="Buscar producto..." 
                                    onEnter={() => {
                                        if (quantityInputRef.current) {
                                            quantityInputRef.current.focus();
                                            quantityInputRef.current.select();
                                        }
                                    }}
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-bold mb-2 text-slate-700">Cantidad</label>
                                <input 
                                    ref={quantityInputRef} 
                                    type="number" 
                                    className="w-full p-3 border rounded-lg text-center text-2xl focus:ring-2 focus:ring-yellow-400 outline-none" 
                                    value={quantity} 
                                    onFocus={(e) => e.target.select()}
                                    onChange={(e) => setQuantity(e.target.value)} 
                                    onKeyDown={handleQuantityKeyDown}
                                />
                            </div>
                            
                            <div className="flex gap-2 mt-4">
                                {isCurrentLocAudited && (
                                    <button 
                                        onClick={() => setIsDeleteConfirmOpen(true)} 
                                        className="bg-red-100 text-red-600 p-4 rounded-lg font-bold hover:bg-red-200 flex items-center justify-center border border-red-200"
                                        title="Borrar Datos"
                                    >
                                        <Icons.Trash />
                                    </button>
                                )}
                                <button onClick={handleSaveAudit} className="flex-1 bg-red-600 text-white font-bold py-4 rounded-lg shadow-lg flex justify-center gap-2 items-center hover:bg-red-700 active:scale-95 transition-transform">
                                    <Icons.Save /> CONFIRMAR
                                </button>
                            </div>
                        </div>
                    </Modal>

                    {/* NUEVA VENTANITA FLOTANTE DE CONFIRMACIÓN */}
                    <Modal isOpen={isDeleteConfirmOpen} onClose={() => setIsDeleteConfirmOpen(false)} title="Eliminar Registro" zIndex={200}>
                        <div className="text-center p-2">
                            <div className="flex justify-center mb-4 text-red-500">
                                <Icons.AlertTriangle width="48" height="48" />
                            </div>
                            <h3 className="font-bold text-lg text-gray-800 mb-2">¿Estás seguro?</h3>
                            <p className="text-sm text-gray-600 mb-6">
                                Se borrarán los datos del lugar <strong>{selectedLocation}</strong> permanentemente de la base de datos.
                            </p>
                            <div className="flex gap-3">
                                <button 
                                    onClick={() => setIsDeleteConfirmOpen(false)}
                                    className="flex-1 py-3 bg-gray-200 text-gray-700 font-bold rounded-lg hover:bg-gray-300"
                                >
                                    Cancelar
                                </button>
                                <button 
                                    onClick={confirmDelete}
                                    disabled={isSaving}
                                    className="flex-1 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 flex justify-center items-center gap-2"
                                >
                                    {isSaving ? 'Borrando...' : 'Sí, Eliminar'}
                                </button>
                            </div>
                        </div>
                    </Modal>

                    {/* MODAL DE CERRAR SESIÓN */}
                    <Modal isOpen={isLogoutConfirmOpen} onClose={() => setIsLogoutConfirmOpen(false)} title="Cerrar Sesión" zIndex={200}>
                        <div className="text-center p-4">
                            <div className="flex justify-center mb-4 text-red-500">
                                <Icons.User width="48" height="48" />
                            </div>
                            <h3 className="font-bold text-lg text-gray-800 mb-2">¿Cerrar sesión?</h3>
                            <p className="text-sm text-gray-600 mb-6">
                                Saldrás de la cuenta <strong>{currentUser}</strong>.
                            </p>
                            <div className="flex gap-3">
                                <button 
                                    onClick={() => setIsLogoutConfirmOpen(false)}
                                    className="flex-1 py-3 bg-gray-200 text-gray-700 font-bold rounded-lg hover:bg-gray-300"
                                >
                                    Cancelar
                                </button>
                                <button 
                                    onClick={confirmLogout}
                                    className="flex-1 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700"
                                >
                                    Salir
                                </button>
                            </div>
                        </div>
                    </Modal>
                </div>
            );
        };

        // Agregar manejo de errores para diagnóstico
        window.addEventListener('error', (e) => {
            console.error('❌ ERROR GLOBAL:', e.error);
            console.error('Mensaje:', e.message);
            console.error('Archivo:', e.filename, 'Línea:', e.lineno);
            if (e.error && e.error.stack) {
                console.error('Stack:', e.error.stack);
            }
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('❌ PROMISE RECHAZADA:', e.reason);
        });
        
        try {
            console.log('🚀 Iniciando aplicación...');
            const rootElement = document.getElementById('root');
            if (!rootElement) {
                throw new Error('No se encontró el elemento #root en el HTML');
            }
            const root = ReactDOM.createRoot(rootElement);
            root.render(<InventoryAuditApp />);
            console.log('✅ Aplicación renderizada correctamente');
        } catch (error) {
            console.error('❌ ERROR AL RENDERIZAR:', error);
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = `
                    <div style="padding: 20px; font-family: monospace; background: #fee; border: 2px solid #f00; margin: 20px; border-radius: 8px;">
                        <h2 style="color: #c00;">❌ Error al cargar la aplicación</h2>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><strong>Stack:</strong></p>
                        <pre style="background: #fff; padding: 10px; overflow: auto; border: 1px solid #ccc;">${error.stack || 'No disponible'}</pre>
                        <p style="margin-top: 20px;"><strong>Instrucciones:</strong></p>
                        <ol>
                            <li>Abre la consola del navegador (presiona F12)</li>
                            <li>Ve a la pestaña "Console"</li>
                            <li>Copia todos los errores que veas (especialmente los que tienen ❌)</li>
                            <li>Envíame esos errores para poder ayudarte</li>
                        </ol>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>
